<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EAS.MicroKernel</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:EAS.Collections.DictionaryWarp`2" -->
        <member name="M:EAS.Collections.DictionaryWarp`2.#ctor">
            <summary>
            初始化DictionaryWarp。
            </summary>
        </member>
        <member name="M:EAS.Collections.DictionaryWarp`2.#ctor(System.Int32)">
            <summary>
            初始化DictionaryWarp对象实例。
            </summary>
            <param name="capacity">容量。</param>
        </member>
        <member name="M:EAS.Collections.DictionaryWarp`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
             <summary>
             初始化DictionaryWarp。
             </summary>
            <param name="dic">字典。</param>
        </member>
        <member name="M:EAS.Collections.DictionaryWarp`2.GetDictionary">
            <summary>
            返回原始记录。
            </summary>
            <returns>字典。</returns>
        </member>
        <member name="M:EAS.Collections.DictionaryWarp`2.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载对象。
            </summary>
            <param name="reader">读取器。</param>
        </member>
        <member name="M:EAS.Collections.DictionaryWarp`2.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            将对象保存到指定的BufferWriter。
            </summary>
            <param name="writer">编写器。</param>
        </member>
        <member name="P:EAS.Collections.DictionaryWarp`2.KeyReader">
            <summary>
            读取方法、反序列化方法。
            </summary>
        </member>
        <member name="P:EAS.Collections.DictionaryWarp`2.ValueReader">
            <summary>
            读取方法、反序列化方法。
            </summary>
        </member>
        <member name="P:EAS.Collections.DictionaryWarp`2.KeyWriter">
            <summary>
            写入方法，完成序列化。
            </summary>
        </member>
        <member name="P:EAS.Collections.DictionaryWarp`2.ValueWriter">
            <summary>
            写入方法，完成序列化。
            </summary>
        </member>
        <member name="P:EAS.Collections.DictionaryWarp`2.Items">
            <summary>
            Key集合/仅在Matrix的XML时使用。
            </summary>
        </member>
        <member name="T:EAS.Collections.KeyValueStruct`2">
            <summary>
            TKey, TValue字典XML序列化结构。
            </summary>
            <typeparam name="TKey">Key类型。</typeparam>
            <typeparam name="TValue">Value类型。</typeparam>
        </member>
        <member name="P:EAS.Collections.KeyValueStruct`2.Key">
            <summary>
            Key。
            </summary>
        </member>
        <member name="P:EAS.Collections.KeyValueStruct`2.Value">
            <summary>
            Value。
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:EAS.Collections.ListWarp`1" -->
        <member name="M:EAS.Collections.ListWarp`1.#ctor">
            <summary>
            初始化ListRoot。
            </summary>
        </member>
        <member name="M:EAS.Collections.ListWarp`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            集合。
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:EAS.Collections.ListWarp`1.GetList">
            <summary>
            返回集合记录。
            </summary>
            <returns></returns>
        </member>
        <member name="P:EAS.Collections.ListWarp`1.Items">
            <summary>
            集合返回值。
            </summary>
        </member>
        <member name="M:EAS.Collections.ListWarp`1.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载对象。
            </summary>
            <param name="reader">读取器。</param>
        </member>
        <member name="M:EAS.Collections.ListWarp`1.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            将对象保存到指定的BufferWriter。
            </summary>
            <param name="writer">编写器。</param>
        </member>
        <member name="P:EAS.Collections.ListWarp`1.Reader">
            <summary>
            读取方法、反序列化方法。
            </summary>
        </member>
        <member name="P:EAS.Collections.ListWarp`1.Writer">
            <summary>
            读取方法、反序列化方法。
            </summary>
        </member>
        <member name="T:EAS.Distributed.Argument">
            <summary>
            RIA实参。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Argument.#ctor">
            <summary>
            初始化Argument对象。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Argument.#ctor(System.Object)">
            <summary>
            根据参数初始化Argument对象。
            </summary>
            <param name="Data">返回数据。</param>
        </member>
        <member name="M:EAS.Distributed.Argument.Deserialize">
            <summary>
            反序列化Argument对象。
            </summary>
            <returns></returns>
        </member>
        <member name="P:EAS.Distributed.Argument.Type">
            <summary>
            类型。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Argument.Pack">
            <summary>
            是否包装。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Argument.Body">
            <summary>
            对象。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Argument.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载消息对象。
            </summary>
            <param name="reader">BufferReader。</param>
        </member>
        <member name="M:EAS.Distributed.Argument.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            保存到指定的BufferWriter。
            </summary>
            <param name="writer">BufferWriter。</param>
        </member>
        <member name="T:EAS.Distributed.Parameter">
            <summary>
            RIA形参。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Parameter.#ctor">
            <summary>
            初始化Parameter对象。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Parameter.#ctor(System.Reflection.ParameterInfo)">
            <summary>
            根据参数初始化Parameter对象。
            </summary>
            <param name="info">参数。</param>
        </member>
        <member name="M:EAS.Distributed.Parameter.Deserialize">
            <summary>
            反序列化Parameter对象。
            </summary>
            <returns></returns>
        </member>
        <member name="P:EAS.Distributed.Parameter.Type">
            <summary>
            类型。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Parameter.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载消息对象。
            </summary>
            <param name="reader">BufferReader。</param>
        </member>
        <member name="M:EAS.Distributed.Parameter.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            保存到指定的BufferWriter。
            </summary>
            <param name="writer">BufferWriter。</param>
        </member>
        <member name="T:EAS.Distributed.Request">
            <summary>
            RIAService的请求消息。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.ServiceType">
            <summary>
            服务定义类型。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.DeclaringType">
            <summary>
            方法定义类型。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.Method">
            <summary>
            方法名称。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.Mac">
            <summary>
            MAC地址。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.HostName">
            <summary>
            主机名称。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.IPAddress">
            <summary>
            IP地址。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.SessionID">
            <summary>
            会话ID。
            </summary> 
        </member>
        <member name="P:EAS.Distributed.Request.DataSet">
            <summary>
            帐套。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.Parameters">
            <summary>
            方法的形参。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Request.Arguments">
            <summary>
            方法的实参。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Request.#ctor">
            <summary>
            初始化Request对象实例。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Request.#ctor(System.Type,System.Reflection.MethodBase,System.Object[])">
            <summary>
            初始化Request对象实例。
            </summary>
            <param name="serviceType">服务方法。</param>
            <param name="method">方法信息。</param>
            <param name="args">实参信息。</param>
        </member>
        <member name="M:EAS.Distributed.Request.Serialize">
            <summary>
            序列化RIA请求为byte[]。
            </summary>
            <returns>byte[]。</returns>
        </member>
        <member name="M:EAS.Distributed.Request.Load(System.Byte[])">
            <summary>
            从字节流中加载Request对象。
            </summary>
            <param name="buffer">字节流。</param>
            <returns>Request对象。</returns>
        </member>
        <member name="M:EAS.Distributed.Request.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载消息对象。
            </summary>
            <param name="reader">BufferReader。</param>
        </member>
        <member name="M:EAS.Distributed.Request.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            保存到指定的BufferWriter。
            </summary>
            <param name="writer">BufferWriter。</param>
        </member>
        <member name="T:EAS.Distributed.Response">
            <summary>
            RIA响应消息。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Response.#ctor">
            <summary>
            初始化响应消息。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Response.#ctor(System.Exception)">
            <summary>
            使用一个错误初始化响应消息。
            </summary>
            <param name="exc">异常实例。</param>
        </member>
        <member name="M:EAS.Distributed.Response.#ctor(System.Object)">
            <summary>
            根据返回对象构造响应消息。
            </summary>
            <param name="Data">返回数据。</param>
        </member>
        <member name="M:EAS.Distributed.Response.Deserialize">
            <summary>
            反序列化响应消息为对象。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Distributed.Response.Serialize">
            <summary>
            序列化RIA响应为byte[]。
            </summary>
            <returns>byte[]。</returns>
        </member>
        <member name="M:EAS.Distributed.Response.Load(System.Byte[])">
            <summary>
            从字节流中加载Response对象。
            </summary>
            <param name="buffer">字节流。</param>
            <returns>Response对象。</returns>
        </member>
        <member name="P:EAS.Distributed.Response.Message">
            <summary>
            错误消息。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Response.Type">
            <summary>
            参数类型。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Response.Pack">
            <summary>
            是否包装。
            </summary>
        </member>
        <member name="P:EAS.Distributed.Response.Body">
            <summary>
            对象。
            </summary>
        </member>
        <member name="M:EAS.Distributed.Response.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载消息对象。
            </summary>
            <param name="reader">BufferReader。</param>
        </member>
        <member name="M:EAS.Distributed.Response.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            保存到指定的BufferWriter。
            </summary>
            <param name="writer">BufferWriter。</param>
        </member>
        <member name="M:EAS.Distributed.NetClass.GetMacAddress">
            <summary>
            取MAC地址。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Distributed.NetClass.GetHostName">
            <summary>
            取计算机名称。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Distributed.NetClass.GetIPAddress">
            <summary>
            取IP地址。
            </summary>
            <returns></returns>
        </member>
        <member name="T:EAS.Distributed.ServiceBridger">
            <summary>
            分布式ServiceBridger。
            </summary>
            <summary>
            分布式RMI访问器分部类，定义保护方法。
            </summary>
        </member>
        <member name="M:EAS.Distributed.ServiceBridger.InvokeMethod(EAS.Services.ServiceProxyInterceptor,System.Reflection.MethodBase,System.Object[])">
            <summary>
            调用远程对象方法。
            </summary>
            <param name="interceptor">方法信息。</param>
            <param name="method">方法定义。</param>
            <param name="args">参数。</param>
            <returns>调用结果。</returns>
        </member>
        <member name="M:EAS.Distributed.ServiceBridger.Dispose">
            <summary>
            已重写。
            </summary>
        </member>
        <member name="P:EAS.Distributed.ServiceBridger.SessionID">
            <summary>
            获取当前会话Guid。
            </summary>
        </member>
        <member name="P:EAS.Distributed.ServiceBridger.DataTag">
            <summary>
            当前会话的数据标记。
            </summary>
            <remarks>
            可以通过本属性来完成向当前会话注入相关信息，比如当前账号信息等。
            </remarks>
        </member>
        <member name="M:EAS.Distributed.ServiceBridger.UpdateSession(System.Object)">
            <summary>
            向会话/服务端注入会话信息。
            </summary>
            <param name="dataTag">会话信息。</param>
        </member>
        <member name="M:EAS.Distributed.ServiceBridger.#ctor">
            <summary>
            初始化 ServiceBridger 对象实例。
            </summary> 
        </member>
        <member name="P:EAS.Distributed.ServiceBridger.ServiceUrl">
            <summary>
            服务名称。
            </summary>
        </member>
        <member name="T:EAS.Distributed.MessageHelper">
            <summary>
            消息辅助类。
            </summary>
        </member>
        <member name="M:EAS.Distributed.MessageHelper.PackageBinary2(System.Object)">
            <summary>
            对消息对象打包。
            </summary>
            <param name="msg">消息对象。</param>
            <returns>打包消息。</returns>
        </member>
        <member name="M:EAS.Distributed.MessageHelper.UnpackageBinary2(System.Type,System.Byte[])">
            <summary>
            解包消息。
            </summary>
            <param name="T">消息类型。</param>
            <param name="callPackage">数据包。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Distributed.MessageHelper.Serialize(System.Object)">
            <summary>
            对消息序列化。
            </summary>
            <param name="msg">消息对象。</param>
            <returns>打包消息。</returns>
        </member>
        <member name="M:EAS.Distributed.MessageHelper.Serialize(System.Type,System.Object)">
            <summary>
            对消息序列化。
            </summary>
            <param name="T">消息类型。</param>
            <param name="msg">消息对象。</param>
            <returns>打包消息。</returns>
        </member>
        <member name="M:EAS.Distributed.MessageHelper.Deserialize(System.Type,System.Byte[])">
            <summary>
            反序列化消息。
            </summary>
            <param name="T">消息类型。</param>
            <param name="buffer">数据流。</param>
            <returns></returns>
        </member>
        <member name="T:EAS.IO.BufferReader">
            <summary>
            基于字节流的消息读取器。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferReader.#ctor(System.Byte[])">
            <summary>
            初始化MessageReader对象实例。
            </summary>
            <param name="buffer">字节流。</param>
        </member>
        <member name="M:EAS.IO.BufferReader.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            初始化MessageReader对象实例。
            </summary>
            <param name="buffer">字节流。</param>
            <param name="position">偏移量。</param>
            <param name="Length">长度。</param>
        </member>
        <member name="P:EAS.IO.BufferReader.Length">
            <summary>
            消息流长度。
            </summary>
        </member>
        <member name="P:EAS.IO.BufferReader.Position">
            <summary>
            当前读取便宜量。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadBytes">
            <summary>
            读字节流。
            </summary>
            <returns>字节流。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadFixBytes(System.Int32)">
            <summary>
            读定长字节流。
            </summary>
            <returns>字节流。</returns>
            <param name="length">长度。</param>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadBoolean">
            <summary>
            读布而值。
            </summary>
            <returns>布而值。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadByte">
            <summary>
            读8位无符号整数。
            </summary>
            <returns> 8位无符号整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadChar">
            <summary>
            读字符。
            </summary>
            <returns>字符。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadInt16">
            <summary>
            读16位整数。
            </summary>
            <returns>16位整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadUInt16">
            <summary>
            读16位无符号整数。
            </summary>
            <returns> 16位无符号整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadInt32">
            <summary>
            读32位整数。
            </summary>
            <returns>32位整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadUInt32">
            <summary>
            读32位无符号整数。
            </summary>
            <returns> 32位无符号整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadInt64">
            <summary>
            读64位整数。
            </summary>
            <returns>64位整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadUInt64">
            <summary>
            读64位无符号整数。
            </summary>
            <returns> 64位无符号整数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadSingle">
            <summary>
            读单精度浮点数字。
            </summary>
            <returns> 单精度浮点数字。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadDouble">
            <summary>
            读双精度浮点数字。
            </summary>
            <returns> 双精度浮点数字。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadDecimal">
            <summary>
            读十进制数。
            </summary>
            <returns> 十进制数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadDateTime">
            <summary>
            读日期时间。
            </summary>
            <returns> 日期时间。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadGuid">
            <summary>
            读Guid值。
            </summary>
            <returns> Guid值。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.ReadString">
            <summary>
            读字符串。
            </summary>
            <returns> 字符串。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.Dispose">
            <summary>
            释放占用的缓存区。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferReader.CreateReadFunc``1">
            <summary>
            创建泛型读取方法
            </summary>
            <typeparam name="T">类型。</typeparam>
            <returns>读取函数。</returns>
        </member>
        <member name="M:EAS.IO.BufferReader.IsNullableType(System.Type)">
            <summary>
            是否为可空类型。
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:EAS.IO.BufferWriter">
            <summary>
            基于字节流的消息编写器。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferWriter.#ctor">
            <summary>
            初始化MessageWriter对象实例。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Byte[])">
            <summary>
            写入字节流。
            </summary>
            <param name="value">字节流。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.WriteFixBytes(System.Byte[])">
            <summary>
            写入字节流/定长。
            </summary>
            <param name="value">字节流。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.String)">
            <summary>
            写入字符串。
            </summary>
            <param name="value">字符串。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Int64)">
            <summary>
            写入64 位整数。
            </summary>
            <param name="value">64 位整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.UInt64)">
            <summary>
            写入64 位无符号整数。
            </summary>
            <param name="value">64 位无符号整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Int32)">
            <summary>
            写入32 位整数。
            </summary>
            <param name="value">32 位整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.UInt32)">
            <summary>
            写入32 位无符号整数。
            </summary>
            <param name="value">32 位无符号整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Int16)">
            <summary>
            写入16 位整数。
            </summary>
            <param name="value">16 位整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.UInt16)">
            <summary>
            写入16 位无符号整数。
            </summary>
            <param name="value">16 位无符号整数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Byte)">
            <summary>
            写入字节值。
            </summary>
            <param name="value">字节值。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Char)">
            <summary>
            写入字符值。
            </summary>
            <param name="value">字符值。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Boolean)">
            <summary>
            写入布尔值。
            </summary>
            <param name="value">布尔值。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Double)">
            <summary>
            写入双精度浮点数。
            </summary>
            <param name="value">双精度浮点数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Single)">
            <summary>
            写入单精度浮点数。
            </summary>
            <param name="value">单精度浮点数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Decimal)">
            <summary>
            写入十进制数。
            </summary>
            <param name="value">十进制数。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.DateTime)">
            <summary>
            写入日期时间。
            </summary>
            <param name="value">日期时间。</param>
        </member>
        <member name="M:EAS.IO.BufferWriter.Write(System.Guid)">
            <summary>
            写入Guid。
            </summary>
            <param name="value">Guid。</param>
        </member>
        <member name="P:EAS.IO.BufferWriter.Length">
            <summary>
            消息流长度。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferWriter.ToArray">
            <summary>
            将内容写入字节数组。
            </summary>
            <returns>字节数组。</returns>
        </member>
        <member name="M:EAS.IO.BufferWriter.Dispose">
            <summary>
            释放占用的缓存区。
            </summary>
        </member>
        <member name="M:EAS.IO.BufferWriter.CreateWriteAction``1">
            <summary>
            创建写入动作。
            </summary>
            <typeparam name="T">类型。</typeparam>
            <returns>写入方法。</returns>
        </member>
        <member name="M:EAS.IO.BufferWriter.IsNullableType(System.Type)">
            <summary>
            是否为可空类型。
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:EAS.IO.InvalidDataException">
            <summary>
            在数据流的格式无效时引发的异常。
            </summary>
        </member>
        <member name="T:EAS.ObjectExtensions">
            <summary>
            对象扩展定义。
            </summary>
        </member>
        <member name="M:EAS.ObjectExtensions.IsNull(System.Object)">
            <summary>
            判断对象是否为空。
            </summary>
            <param name="value">对象。</param>
            <returns>为空对象返回true，否则返回false。</returns>
        </member>
        <member name="T:EAS.TypeExtensions">
            <summary>
            类型扩展方法
            </summary>
        </member>
        <member name="M:EAS.TypeExtensions.GetTName(System.Type)">
            <summary>
            获取类型的文本。
            </summary>
            <param name="T"></param>
            <returns></returns>
        </member>
        <member name="M:EAS.TypeExtensions.GetAssemblyName(System.Type)">
            <summary>
            获取类型的文本。
            </summary>
            <param name="T"></param>
            <returns></returns>
        </member>
        <member name="M:EAS.TypeExtensions.CreateType(System.String,System.String)">
            <summary>
            创建类型。
            </summary>
            <param name="Type"></param>
            <param name="Assembly"></param>
            <returns></returns>
        </member>
        <member name="M:EAS.TypeExtensions.GetBytes(System.Type)">
            <summary>
            求类型的二进制表示。
            </summary>
            <param name="type">类型信息。</param>
            <returns>类型的二进制流表示。</returns>
        </member>
        <member name="M:EAS.TypeExtensions.FormBytes(System.Byte[])">
            <summary>
            从二进制流读取类型信息。
            </summary>
            <param name="buffer">类型的二进制流表示。</param>
            <returns>类型信息。</returns>
        </member>
        <member name="T:EAS.Serialization.ISerializableEx">
            <summary>
            AgileEAS.NET SOA中间件平台所提供的特有的序列化方案接口。
            </summary>
        </member>
        <member name="M:EAS.Serialization.ISerializableEx.Load(EAS.IO.BufferReader)">
            <summary>
            从指定的 BufferReader加载对象。
            </summary>
            <param name="reader">读取器。</param>
        </member>
        <member name="M:EAS.Serialization.ISerializableEx.WriteTo(EAS.IO.BufferWriter)">
            <summary>
            将对象保存到指定的BufferWriter。
            </summary>
            <param name="writer">编写器。</param>
        </member>
        <member name="T:EAS.Serialization.SerializeHelper">
            <summary>
            序列化辅助类，支持Json与XML格式。
            </summary>
        </member>
        <member name="M:EAS.Serialization.SerializeHelper.SerializeXml``1(``0)">
            <summary>
            使用XML序列化对象
            </summary>
            <typeparam name="T">对象类型。</typeparam>
            <param name="instance">对象。</param>
            <returns>XML字符串。</returns>
        </member>
        <member name="M:EAS.Serialization.SerializeHelper.DeserializeXml``1(System.String)">
            <summary>
            反序列化对象。
            </summary>
            <typeparam name="T">对象类型。</typeparam>
            <param name="xml">XML字符串。</param>
            <returns>对象实例。</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:EAS.Serialization.SerializeHelper.SerializeXml(System.Type,System.Object)" -->
        <member name="M:EAS.Serialization.SerializeHelper.DeserializeXml(System.Type,System.String)">
            <summary>
            反序列化对象。
            </summary>
            <param name="T">对象类型。</param>
            <param name="xml">XML字符串。</param>
            <returns>对象实例。</returns>
        </member>
        <member name="T:EAS.StringExtension">
            <summary>
            字符串扩展。
            </summary>
        </member>
        <member name="M:EAS.StringExtension.ToSBC(System.String)">
            <summary>
            Transfer full-function (SBC case)，Any string Full-width strings。
            </summary>
            <param name="input"></param>
            <returns></returns>
            <remarks>
            Em space is 12288, half-width spaces to 32，Other characters, half-width (33-126) and (65281-65374) of the correspondence is: difference of 65248。
            </remarks>
        </member>
        <member name="M:EAS.StringExtension.ToSBC(System.Char)">
            <summary>
            Transfer full-function (SBC case)，Any string Full-width strings。
            </summary>
            <param name="input"></param>
            <returns></returns>
            <remarks>
            Em space is 12288, half-width spaces to 32，Other characters, half-width (33-126) and (65281-65374) of the correspondence is: difference of 65248。
            </remarks>
        </member>
        <member name="M:EAS.StringExtension.ToDBC(System.String)">
            <summary>
            Turn/half angle function (DBC case)，Random string，Half/full width strings。
            </summary>
            <param name="input"></param>
            <returns></returns>
            <remarks>
            12288/full-width spaces, half-width spaces to 32,Other characters, half-width/(33-126) and (65281-65374) of the correspondence is: difference of 65248。
            </remarks>
        </member>
        <member name="M:EAS.StringExtension.ToDBC(System.Char)">
            <summary>
            Turn/half angle function (DBC case)，Random string，Half/full width strings。
            </summary>
            <param name="input"></param>
            <returns></returns>
            <remarks>
            12288/full-width spaces, half-width spaces to 32,Other characters, half-width/(33-126) and (65281-65374) of the correspondence is: difference of 65248。
            </remarks>
        </member>
        <member name="M:EAS.StringExtension.IsEmpty(System.String)">
            <summary>
            判断字符串是否为空
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsInteger(System.String)">
            <summary>
            判断字符串是否为整型
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsPositiveInteger(System.String)">
            <summary>
            判断字符串是否为正整型
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsPositiveInt64(System.String)">
            <summary>
            判断字符串是否为正整型
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsNegativeInteger(System.String)">
            <summary>
            判断字符串是否为负整数
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsNegativeInt64(System.String)">
            <summary>
            判断字符串是否为负整数
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsFloat(System.String)">
            <summary>
            判断字符串是否为浮点型
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsDecimal(System.String)">
            <summary>
            判断字符串是否为十进制数
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsPositiveNumber(System.String)">
            <summary>
            判断字符串是否为正数
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.IsNegativeNumber(System.String)">
            <summary>
            判断字符串是否为负数
            </summary>
            <param name="s">字符串</param>
            <returns>结果</returns>
        </member>
        <member name="M:EAS.StringExtension.ToInt(System.String)">
            <summary>
            将字符串转化为整型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>整型值，转化失败默认返回0</returns>
        </member>
        <member name="M:EAS.StringExtension.ToInt64(System.String)">
            <summary>
            将字符串转化为整型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>整型值，转化失败默认返回0</returns>
        </member>
        <member name="M:EAS.StringExtension.ToDouble(System.String)">
            <summary>
            将字符串转化为Double类型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>Double值，转化失败默认返回0</returns>
        </member>
        <member name="M:EAS.StringExtension.ToDecimal(System.String)">
            <summary>
            将字符串转化为Decimal类型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>Double值，转化失败默认返回0</returns>
        </member>
        <member name="M:EAS.StringExtension.ToDateTime(System.String)">
            <summary>
            将字符串转化为时间类型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>时间，转化失败默认返回最小时间</returns>
        </member>
        <member name="M:EAS.StringExtension.ToFloat(System.String)">
            <summary>
            将字符串转化为浮点型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>浮点值，转化失败默认返回0</returns>
        </member>
        <member name="M:EAS.StringExtension.ToBoolean(System.String)">
            <summary>
            将字符串转化为布尔型
            </summary>
            <remarks>扩展方法</remarks>
            <returns>布尔值，转化失败默认返回false</returns>
        </member>
        <member name="F:EAS.StringExtension.strChineseFirstPY">
            <summary>
            汉字拼音首字母列表 本列表包含了20901个汉字,用于配合 ToPinYin 函数使用,本表收录的字符的Unicode编码范围为19968至40869
            </summary>
        </member>
        <member name="M:EAS.StringExtension.ToPinYin(System.String)">
            <summary>
            获得一个字符串的汉语拼音码,XDesigner编制
            </summary>
            <param name="s">字符串</param>
            <returns>汉语拼音码,该字符串只包含大写的英文字母</returns>
        </member>
        <member name="M:EAS.StringExtension.ToWubi(System.String)">
            <summary>
            获得一个字符串的五笔简码。
            </summary>
            <param name="s">字符串</param>
            <returns>五笔输入码/首码。</returns>
        </member>
        <member name="M:EAS.StringExtension.StartsWithEx(System.String,System.String)">
            <summary>
            StartsWith扩展，实现类型sql的皮配功能。
            </summary>
            <param name="s"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:EAS.StringExtension.StartsWithEx(System.String,System.String,System.StringComparison)">
            <summary>
            StartsWith扩展，实现类型sql的皮配功能。
            </summary>
            <param name="s"></param>
            <param name="input"></param>
            <param name="comparisonType"></param>
            <returns></returns>
        </member>
        <member name="T:EAS.Threading.IWorkerEngine">
            <summary>
            工作者引擎。
            </summary>
        </member>
        <member name="M:EAS.Threading.IWorkerEngine.Initialize">
            <summary>
            初始化工作者引擎。
            </summary>
        </member>
        <member name="M:EAS.Threading.IWorkerEngine.Start">
            <summary>
            启动引擎。
            </summary>
        </member>
        <member name="M:EAS.Threading.IWorkerEngine.Stop">
            <summary>
            停止引擎。
            </summary>
        </member>
        <member name="T:EAS.Threading.ThreadSafeObject`1">
            <summary>
            提供多线程安全访问内部成员Value。    
            </summary>
            <typeparam name="T">对象类型。</typeparam>
        </member>
        <member name="F:EAS.Threading.ThreadSafeObject`1._tObject">
            <summary>
            值
            </summary>
        </member>
        <member name="F:EAS.Threading.ThreadSafeObject`1._lock">
            <summary>
            锁
            </summary>
        </member>
        <member name="M:EAS.Threading.ThreadSafeObject`1.#ctor">
            <summary>
            线程安全访问内部成员Value类型
            </summary>
        </member>
        <member name="M:EAS.Threading.ThreadSafeObject`1.#ctor(`0)">
            <summary>
            线程安全访问内部成员Value类型
            </summary>
            <param name="defaultValue">内部成员Value成员初始值</param>
        </member>
        <member name="P:EAS.Threading.ThreadSafeObject`1.Value">
            <summary>
            获取或设置内部成员
            </summary>
        </member>
        <member name="T:EAS.Modularization.AddInAttribute">
            <summary>
            EAS.NET插件属性。
            </summary>
            <remarks>
            提供IAddIn的标记实现,提供基于属性标记的插件实现。
            </remarks>
        </member>
        <member name="M:EAS.Modularization.AddInAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化AddInAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
        </member>
        <member name="M:EAS.Modularization.AddInAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            初始化AddInAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
            <param name="description">模块说明。</param>
        </member>
        <member name="M:EAS.Modularization.AddInAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            初始化AddInAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
            <param name="group">模块分组。</param>
            <param name="description">模块说明。</param>
        </member>
        <member name="P:EAS.Modularization.AddInAttribute.Guid">
            <summary>
            模块Guid。
            </summary>
        </member>
        <member name="P:EAS.Modularization.AddInAttribute.Name">
            <summary>
            模块名称。
            </summary>
        </member>
        <member name="P:EAS.Modularization.AddInAttribute.Group">
            <summary>
            模块分组。
            </summary>
        </member>
        <member name="P:EAS.Modularization.AddInAttribute.Description">
            <summary>
            模块说明。
            </summary>
        </member>
        <member name="T:EAS.Modularization.AddInStartAttribute">
            <summary>
            模块入口方法属性。
            </summary>
            <remarks>
            配合 AddInAttribute实现基于标记的IAddIn模块。
            </remarks>
        </member>
        <member name="M:EAS.Modularization.AddInStartAttribute.#ctor">
            <summary>
            初始化ModuleStartAttribute对象。
            </summary>
        </member>
        <member name="T:EAS.Modularization.ModuleAttribute">
            <summary>
            EAS.NET模块插件属性。
            </summary>
            <remarks>
            提供IModule的标记实现,提供基于属性标记的插件实现。
            </remarks>
        </member>
        <member name="M:EAS.Modularization.ModuleAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化ModuleAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
        </member>
        <member name="M:EAS.Modularization.ModuleAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            初始化ModuleAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
            <param name="description">模块说明。</param>
        </member>
        <member name="M:EAS.Modularization.ModuleAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            初始化ModuleAttribute对象。
            </summary>
            <param name="guid">模块Guid。</param>
            <param name="name">模块名称。</param>
            <param name="group">模块分组。</param>
            <param name="description">模块说明。</param>
        </member>
        <member name="T:EAS.Modularization.ModuleStartAttribute">
            <summary>
            模块入口方法属性。
            </summary>
            <remarks>
            配合ModuleAttribute实现基于标记的IMoule模块。
            </remarks>
        </member>
        <member name="M:EAS.Modularization.ModuleStartAttribute.#ctor">
            <summary>
            初始化ModuleStartAttribute对象。
            </summary>
        </member>
        <member name="T:EAS.AddInEventHandler">
            <summary>
            定义模块处理代理。
            </summary>
            <param name="sender">事件源。</param>
            <param name="e">包含事件数据的 EAS.AddInEventArgs。</param>
        </member>
        <member name="T:EAS.AddInEventArgs">
            <summary>
            模块加载和关闭事件。
            </summary>
        </member>
        <member name="M:EAS.AddInEventArgs.#ctor(System.Object)">
            <summary>
            初始化AddInEventArgs对象实例。
            </summary>
            <param name="addIn"></param>
        </member>
        <member name="P:EAS.AddInEventArgs.AddIn">
            <summary>
            获取模块插件。
            </summary>
        </member>
        <member name="T:EAS.Application">
            <summary>
            定义AgileEAS.NET平台应用程序(IApplication的抽像实现)。
            </summary>
        </member>
        <member name="P:EAS.Application.Instance">
             <summary>
            插件平台的唯一实例。
             </summary>
        </member>
        <member name="M:EAS.Application.SetInstance(EAS.IPlatform)">
            <summary>
            设置AgileEAS.NET平台实例。
            </summary>
            <param name="instance">平台实例对象。</param>
        </member>
        <member name="P:EAS.Application.Name">
            <summary>
            获取应用程序名称。
            </summary>
        </member>
        <member name="P:EAS.Application.Session">
            <summary>
            获取容器的当前会话。
            </summary>
        </member>
        <member name="P:EAS.Application.Time">
            <summary>
            获取系统当前时间。
            </summary>
        </member>
        <member name="P:EAS.Application.WorkflowRuntime">
            <summary>
            获取工作流运行时环境。
            </summary>
        </member>
        <member name="M:EAS.Application.StartModule(System.Object)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块插件。</param>
        </member>
        <member name="M:EAS.Application.StartModule(System.Type)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块类型。</param>
        </member>
        <member name="M:EAS.Application.StartModule(System.Guid)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块Guid。</param>
        </member>
        <member name="M:EAS.Application.CloseModule(System.Object)">
            <summary>
            关闭模块。
            </summary>
            <param name="addIn">模块插件。</param>
        </member>
        <member name="M:EAS.Application.CloseModule">
            <summary>
            关闭当前模块。
            </summary>
        </member>
        <member name="M:EAS.Application.CallScript(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            执行脚本。
            </summary>
            <param name="script">脚本代码。</param>
            <param name="args">调用参数。</param>
            <remarks>
            动态向用户提供平台的调用。
            </remarks>
        </member>
        <member name="M:EAS.Application.AppStart">
            <summary>
            启动Windows应用程序。
            </summary>
        </member>
        <member name="M:EAS.Application.Login(System.String,System.String)">
            <summary>
            账户登录。
            </summary>
            <param name="loginID">账户登录ID。</param>
            <param name="password">账户密码。</param>
        </member>
        <member name="M:EAS.Application.Login(System.String,System.String,System.String)">
            <summary>
            账户登录。
            </summary>
            <param name="organization">组织机构。</param>
            <param name="loginID">账户登录ID。</param>
            <param name="password">账户密码。</param>
        </member>
        <member name="M:EAS.Application.ChangePassword">
            <summary>
            修改密码。
            </summary>
        </member>
        <member name="M:EAS.Application.Logout">
            <summary>
            账户注销。
            </summary>
        </member>
        <member name="M:EAS.Application.AppEnd">
            <summary>
            终止Windows应用程序。
            </summary>
        </member>
        <member name="P:EAS.Application.Context">
            <summary>
            获取对象上下文环境。
            </summary>
        </member>
        <member name="P:EAS.Application.Container">
            <summary>
            获取组件容器。
            </summary>
        </member>
        <member name="E:EAS.Application.Started">
            <summary>
            当平台启动完成后发生。
            </summary>
        </member>
        <member name="E:EAS.Application.Notify">
            <summary>
            当平台发出通知时发生。
            </summary>
        </member>
        <member name="E:EAS.Application.AddInClosing">
            <summary>
            平台关闭模块时触发。
            </summary>
        </member>
        <member name="E:EAS.Application.AddLoad">
            <summary>
            平台成功加载模块之后触发。
            </summary>
        </member>
        <member name="M:EAS.Application.OnStarted(System.EventArgs)">
            <summary>
            引发 Started 事件。
            </summary>
            <param name="e">一个 System.EventArgs，其中包含事件数据。</param>
        </member>
        <member name="M:EAS.Application.OnNotify(EAS.NotifyEventArgs)">
            <summary>
            引发 Notify 事件。
            </summary>
            <param name="e">一个 EAS.NotifyEventArgs，其中包含事件数据。</param>
        </member>
        <member name="M:EAS.Application.OnAddLoad(EAS.AddInEventArgs)">
            <summary>
            引发 AddLoad 事件。
            </summary>
            <param name="e">一个 EAS.AddInEventArgs，其中包含事件数据。</param>
        </member>
        <member name="M:EAS.Application.OnAddInClosing(EAS.AddInEventArgs)">
            <summary>
            引发 AddInClosing 事件。
            </summary>
            <param name="e">一个 EAS.AddInEventArgs，其中包含事件数据。</param>
        </member>
        <member name="T:EAS.Data.UIAlignment">
            <summary>
            数据对齐方式。
            </summary>
        </member>
        <member name="F:EAS.Data.UIAlignment.Left">
            <summary>
            在对齐。
            </summary>
        </member>
        <member name="F:EAS.Data.UIAlignment.Center">
            <summary>
            居中对齐。
            </summary>
        </member>
        <member name="F:EAS.Data.UIAlignment.Right">
            <summary>
            右对齐。
            </summary>
        </member>
        <member name="T:EAS.Data.AutoUIAttribute">
            <summary>
            界面自动布局属性。
            </summary>
        </member>
        <member name="M:EAS.Data.AutoUIAttribute.#ctor">
            <summary>
            初始化AutoUIAttribute属性。
            </summary>
        </member>
        <member name="M:EAS.Data.AutoUIAttribute.#ctor(System.Int32)">
            <summary>
            初始化AutoUIAttribute属性。
            </summary>
            <param name="width">宽度。</param>
        </member>
        <member name="M:EAS.Data.AutoUIAttribute.#ctor(System.Int32,EAS.Data.UIAlignment)">
            <summary>
            初始化AutoUIAttribute属性。
            </summary>
            <param name="width">宽度。</param>
            <param name="alignment">对齐方式。</param>
        </member>
        <member name="M:EAS.Data.AutoUIAttribute.#ctor(System.String,System.Int32)">
            <summary>
            初始化AutoUIAttribute属性。
            </summary>
            <param name="caption">标题。</param>
            <param name="width">宽度。</param>
        </member>
        <member name="M:EAS.Data.AutoUIAttribute.#ctor(System.String,System.Int32,EAS.Data.UIAlignment)">
            <summary>
            初始化AutoUIAttribute属性。
            </summary>
            <param name="caption">标题。</param>
            <param name="width">宽度。</param>
            <param name="alignment">对齐方式。</param>
        </member>
        <member name="P:EAS.Data.AutoUIAttribute.Caption">
            <summary>
            标题。
            </summary>
        </member>
        <member name="P:EAS.Data.AutoUIAttribute.Width">
            <summary>
            宽度。
            </summary>
        </member>
        <member name="P:EAS.Data.AutoUIAttribute.Alignment">
            <summary>
            对齐方式。
            </summary>
        </member>
        <member name="P:EAS.Data.AutoUIAttribute.Format">
            <summary>
            显示格式。
            </summary>
        </member>
        <member name="P:EAS.Data.AutoUIAttribute.Index">
            <summary>
            显示顺序号。
            </summary>
        </member>
        <member name="T:EAS.Data.Binding.IDataBind">
            <summary>
            数据绑定接口。
            </summary>
            <remarks>
            用于定义数据实体同界面的交互绑定机制。
            </remarks>
        </member>
        <member name="E:EAS.Data.Binding.IDataBind.DataEntityChanged">
            <summary>
            当前数据对象发生改变时触发该事件。
            </summary>
        </member>
        <member name="P:EAS.Data.Binding.IDataBind.DataEntity">
            <summary>
            获取或者设置绑定目标对象的数据实体。
            </summary>
        </member>
        <member name="P:EAS.Data.Binding.IDataBind.TDataEntity">
            <summary>
            获取绑定目标对象的数据实体类型。
            </summary>
        </member>
        <member name="T:EAS.Objects.EmptyAssemblyLoader">
            <summary>
            空的程序集加载器。
            </summary>
        </member>
        <member name="P:EAS.Objects.EmptyAssemblyLoader.Container">
            <summary>
            目标组件容器。
            </summary>
        </member>
        <member name="M:EAS.Objects.EmptyAssemblyLoader.Initialize">
            <summary>
            初始化容器。
            </summary>
        </member>
        <member name="T:EAS.Objects.XmlAssemblyLoader">
            <summary>
            xml配置程序集加载器。
            </summary>
        </member>
        <member name="P:EAS.Objects.XmlAssemblyLoader.Container">
            <summary>
            目标组件容器。
            </summary>
        </member>
        <member name="M:EAS.Objects.XmlAssemblyLoader.Initialize">
            <summary>
            初始化容器。
            </summary>
        </member>
        <member name="T:EAS.Objects.ContainerBuilder">
            <summary>
            构件容器构造器，用于完成构件容器的构造功能。
            </summary>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.Builder">
            <summary>
            从系统配置文件自动构造容器实例。
            </summary>		
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.GetDefaultContainer">
            <summary>
            获取系统上下文环境默认的构件容器实例。
            </summary>		
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.BuilderDefault">
            <summary>
            从系统配置文件自动构造容器实例。
            </summary>		
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.BuilderDefault(System.String)">
            <summary>
            从系统配置文件自动构造容器实例。
            </summary>
            <param name="name"> 名称。</param>
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.BuilderEmpty">
            <summary>
            构造构件容器实例（空容器、不包括任何实例）。
            </summary>		
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerBuilder.Builder(EAS.Objects.IAssemblyLoader)">
            <summary>
            根据程序集装载器构造构件容器。
            </summary>		
            <returns>构件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.AssemblyCacheProvider.#ctor">
            <summary>
            初始化 AssemblyCacheProvider 对象实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.AssemblyCacheProvider.Instance">
            <summary>
            对象的唯一实例。
            </summary>
        </member>
        <member name="T:EAS.Objects.ClassProvider">
            <summary>
            类/对象提供者，为对象实例化提供的辅助类。
            </summary>
        </member>
        <member name="M:EAS.Objects.ClassProvider.AddXapStream(System.Windows.Resources.StreamResourceInfo)">
            <summary>
            添加Xap程序包。
            </summary>
            <param name="xapStream">Xap包的资源信息。</param>
        </member>
        <member name="M:EAS.Objects.ClassProvider.ContainsAssembly(System.String)">
            <summary>
            程序集是否已经装入应用程序区域。
            </summary>
            <param name="assemblyName">程序集名称。</param>
            <returns>是否包指定的程序集。包含则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetAssembly(System.String)">
            <summary>
            取得指定名称的程序集。
            </summary>
            <param name="assemblyName">程序集名称。</param>
            <returns>如果执行成功，返回指定的程序集实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.LoadXap(System.Windows.Resources.StreamResourceInfo)">
            <summary>
            加载Xap包。
            </summary>
            <param name="xapStream">Xap包的资源信息。</param>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetType(System.String)">
            <summary>
            获取指定的类型。
            </summary>
            <param name="type">类型信息。</param>
            <returns>如果执行成功，返回指定的程序集实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetTypeText(System.String,System.Int32@)">
            <summary>
            求泛型参数。
            </summary>
            <param name="Text2"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetIndex1(System.String)">
            <summary>
            求字符串中第一个[出现的位置。
            </summary>
            <param name="Text"></param>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetIndex2(System.String)">
            <summary>
            求字符串中第最后]出现的位置。
            </summary>
            <param name="Text"></param>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetType(System.String,System.String)">
            <summary>
            获取指定的类型。
            </summary>
            <param name="assemblyName">程序集名称。</param>
            <param name="type">类型。</param>
            <returns>如果执行成功，返回指定的程序集实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetObjectInstance(System.String,System.String)">
            <summary>
            取得对象实例。
            </summary>
            <param name="assemblyName">程序集名称。</param>
            <param name="type">对象类型。</param>
            <returns>如果执行成功，返回生成的对象实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetObjectInstance(System.Type)">
            <summary>
            取得对象实例。
            </summary>
            <param name="type">对象类型。</param>
            <returns>如果执行成功，返回生成的对象实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetObjectInstance``1">
            <summary>
            取得对象实例。
            </summary>
            <typeparam name="T">对象类型信息。</typeparam>
            <returns>如果执行成功，返回生成的对象实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="M:EAS.Objects.ClassProvider.GetObjectInstance(System.Type,System.Object[])">
            <summary>
            取得对象实例。
            </summary>
            <param name="type">对象类型。</param>
            <param name="args">对象构造参数。</param>
            <returns>如果执行成功，返回生成的对象实例，否则返回null(Nothing)。</returns>
        </member>
        <member name="T:EAS.Objects.ComponentConfig">
            <summary>
            系统配置读取类。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentConfig.Components">
            <summary>
            获取Objects中配置的对象配置信息。
            </summary>
        </member>
        <member name="M:EAS.Objects.ComponentConfig.GetComponentInfo(System.String)">
            <summary>
            根据对象名称（索引键）获取对象配置信息。
            </summary>
            <param name="name">对象名称。</param>
            <returns>对象配置信息。</returns>
        </member>
        <member name="T:EAS.Objects.ConfigInfo">
            <summary>
            Objects配置信息。
            </summary>
        </member>
        <member name="M:EAS.Objects.ConfigInfo.#ctor">
            <summary>
            初始化 ConfigInfo 类对象实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.ConfigInfo.Objects">
            <summary>
            获取Objects中配置的对象配置信息。
            </summary>
        </member>
        <member name="T:EAS.Objects.ConstructorInfo">
            <summary>
            Objects容器中对于对象构造注入的属性信息。
            </summary>
        </member>
        <member name="M:EAS.Objects.ConstructorInfo.#ctor">
            <summary>
            初始化 ConstructorInfo 类实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.ConstructorInfo.Index">
            <summary>
            获取或设置一个值，批示构造器参数索引。
            </summary>
        </member>
        <member name="P:EAS.Objects.ConstructorInfo.Type">
            <summary>
            获取或设置一个值，批示构造参数的数据类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.ConstructorInfo.Expression">
            <summary>
            获取或设置一个值，批示构造参数的表达式。
            </summary>
        </member>
        <member name="T:EAS.Objects.ContainerFactory">
            <summary>
            组件容器工厂,完成组件容器的创建工作。
            </summary>
        </member>
        <member name="M:EAS.Objects.ContainerFactory.Create">
            <summary>
            生成组件容器实例。
            </summary>		
            <returns>组件容器实例。</returns>
        </member>
        <member name="M:EAS.Objects.ContainerFactory.Create(EAS.Objects.IAssemblyLoader)">
            <summary>
            根据程序集装载器生成组件容器。
            </summary>		
            <returns>组件容器实例。</returns>
        </member>
        <member name="T:EAS.Objects.DefaultComponentAdapter">
            <summary>
            DefaultComponentAdapter 的摘要说明。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultComponentAdapter.container">
            <summary>
            组件容器。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultComponentAdapter.m_ComponentInfo">
            <summary>
            配置定义。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultComponentAdapter._CI">
            <summary>
            构造拦截器。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultComponentAdapter._PI">
            <summary>
            属性拦截器。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter._ConstructorInjector">
            <summary>
            构造拦截器。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter._PropertyInjector">
            <summary>
            属性拦截器。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.#ctor(EAS.Objects.ComponentInfo)">
            <summary>
            使用组件的键和实现类型初始化组件适配器。
            </summary>
            <param name="componentInfo">组件定义信息。</param>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.#ctor(System.String,System.String,System.Type)">
            <summary>
            使用组件的键和实现类型初始化组件适配器。
            </summary>
            <param name="componentKey">组件的键。</param>
             <param name="assembly">组件所在的程序集名称。</param>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.#ctor(System.String,System.String,System.Type,System.Type)">
            <summary>
            使用组件的键和实现类型初始化组件适配器。
            </summary>
            <param name="componentKey">组件的键。</param>
            <param name="assembly">组件所在的程序集名称。</param>
            <param name="serviceType">组件的接口类型。</param>
            <param name="componentImplementation"> 组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.#ctor(System.String,System.String,System.Type,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            使用组件的键、实现类型及生存方式初始化组件适配器。
            </summary>
            <param name="componentKey">组件的键。</param>
            <param name="assembly">组件所在的程序集名称。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="lifestyleType">组件生存方式。</param>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.#ctor(System.String,System.String,System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
             使用组件的键、接口类型，实现类型及生存方式初始化组件适配器。
            </summary>
            <param name="componentKey">组件的键。</param>
            <param name="assembly">组件所在的程序集名称。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="lifestyleType">组件生存方式。</param>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.ComponentKey">
            <summary>
            获取一个值，指示组件的键。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.Assembly">
            <summary>
            返回组件所在程序集名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.ServiceType">
            <summary>
            获取一个值，指示组件的接口（服务类型）类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.ComponentImplementation">
            <summary>
            获取一个值，指示组件的实现类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.LifestyleType">
            <summary>
            返回组件的生存方式。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.Create">
            <summary>
            创建一个组件实例。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.DefaultComponentAdapter.Destroy(System.Object)">
            <summary>
            销毁组件实例。
            </summary>
            <param name="instance"></param>
        </member>
        <member name="P:EAS.Objects.DefaultComponentAdapter.Container">
            <summary>
            获取或设置一个值，指示组件适配器所属的组件容器。
            </summary>
        </member>
        <member name="T:EAS.Objects.DefaultContainer">
            <summary>
            DefaultContainer 的摘要说明。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.m_ComponentInfos">
            <summary>
            组件配置定义。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.componentInstances">
            <summary>
            私有内部成员，组件容器中的所有注册组件实例。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.lifecycleManagers">
            <summary>
            私有内部成员，组件容器中的组件生存期管理对象集合。其值为组件键/生存期管理对象接口实例。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.componentAdapters">
            <summary>
            私有内部成员，组件容器中的组件适配器对象集合。其值为组件键/组件适配器接口实例。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.name">
            <summary>
            容器名称。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer._AssemblyLoader">
            <summary>
            程序集装载器。
            </summary>
        </member>
        <member name="F:EAS.Objects.DefaultContainer.fInitialize">
            <summary>
            是否已初始化。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.#ctor">
            <summary>
            初始化 DefaultContainer 实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.#ctor(EAS.Objects.IAssemblyLoader)">
            <summary>
            初始化 DefaultContainer 实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.Finalize">
            <summary>
            DefaultContainer 对象析构函数
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.Initialize">
            <summary>
            初始化组件容器。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.Name">
             <summary>
            获取容器名称。
             </summary>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.ComponentInfos">
            <summary>
            组织配置信息。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(EAS.Objects.ComponentInfo)">
            <summary>
            根据组件组件信息向容器注册组件实现。
            </summary>
            <param name="componentInfo">组件信息。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.String,System.Type)">
            <summary>
            根据组件组件key及组件实现类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation"></param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            根据组件key、接口类型及实现类型中注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.String,System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="lifestyleType"> 组件生命周期方式。 </param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.String,System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType,System.String)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="lifestyleType"> 组件生命周期方式。 </param>
            <param name="lifestyleParameters"> 组件生命周期相关参数，参数为一个字符串，其中由“：”分隔。 </param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.Type)">
            <summary>
            根据组件实现类型向容器注册组件实现。
            </summary>		
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.Type,System.Type)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.Object)">
            <summary>
            根据组件实例向组件容器中注册组件。
            </summary>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.Type)">
            <summary>
            根据组件实现类型向组件容器中注册组件。
            </summary>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.String,System.Type)">
            <summary>
            根据组件key、组件实现向组件容器中注册组件。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.String,System.Object)">
            <summary>
            根据组件key及组件实现向组件容器中注册组件。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            根据组件key、接口类型及组件实例向组件容器中注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponentInstance(System.String,System.Type,System.Object,EAS.Objects.Lifecycle.LifestyleType,System.String)">
            <summary>
            根据组件key、接口类型、组件实例及组件生存类型向组件容器中注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentInstance">组件实例。</param>
            <param name="lifestyleType"> 组件生命周期方式。 </param>
            <param name="lifestyleParameters"> 组件生命周期相关参数，参数为一个字符串，其中由“：”分隔。 </param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.RemoveComponent(System.String)">
            <summary>
            根据组件key从组件容器中移除组件实现。
            </summary>
            <param name="componentKey">组件key。</param>		
        </member>
        <member name="M:EAS.Objects.DefaultContainer.RemoveComponent(System.Object)">
            <summary>
            根据组件实例从组件容器中移除组件实现。
            </summary>
            <param name="componentInstance">组件实例。</param>		
        </member>
        <member name="M:EAS.Objects.DefaultContainer.RemoveComponent(System.String,System.Object)">
            <summary>
            根据组件key及组件实例从组件容器中移除组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentInstance">组件实例。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.HasComponent(System.String)">
            <summary>
            根据组件key判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="componentKey">组件key。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.HasComponent(System.Object)">
            <summary>
            根据组件实例判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="componentInstance">组件实例。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.HasComponent(System.Type)">
            <summary>
            根据组件接口类型判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns></returns>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.Item(System.String)">
            <summary>
            组件索引器，获取指定Key值的组件实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.Item(System.Type)">
            <summary>
            组件索引器，获取指定接口类型的组件实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.ReleaseComponent(System.Object)">
            <summary>
            根据组件实例从组件容器中释放组件实例。
            </summary>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.ReleaseComponent(System.String)">
            <summary>
            根据组件Key从组件容器中释放组件实例。
            </summary>
            <param name="componentKey">组件Key。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstance(System.String)">
            <summary>
            根据组件的key取得组件实例。
            </summary>
            <param name="componentKey">组件的key。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstance(System.Type)">
            <summary>
            根据组件的类型取得组件实例。
            </summary>
            <param name="serviceType">组件类型。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetServiceComponentInstance(System.Type)">
            <summary>
            根据组件服务类型取得组件实例。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.ComponentInstances">
            <summary>
            获取一个值，批示容器中所有的组件实例列表。
            </summary>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.ComponentAdapters">
            <summary>
            获取一个值，该值批示组件容器中的所有组件适配器列表。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstances(System.Type)">
            <summary>
            根据组件类型取得组件实例列表。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns>组件实例列表。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentAdapter(System.String)">
            <summary>
            根据组件key取得与组件相关的组件适配器。
            </summary>
            <param name="componentKey">组件的key。</param>
            <returns>指定组件的组件适配器。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentAdapter(System.Type)">
            <summary>
            根据组件类型取得与组件相关的组件适配器。
            </summary>
            <param name="componentType">组件类型。</param>
            <returns>指定组件类型的组件适配器。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentAdapters(System.Type)">
            <summary>
            根据组件类类型获取组件适配器列表。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns>指定组件类型的组件适配器列表。</returns>
        </member>
        <member name="P:EAS.Objects.DefaultContainer.LifecycleManagers">
            <summary>
            获取一个值，该值批示组件容器中的所有组件生命周期管理器列表。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetLifecycleManager(System.String)">
            <summary>
            根据组件key取得与组件相关的组件生命周期管理器。
            </summary>
            <param name="componentKey"> 组件的键。</param>
            <returns>指定组件键的生命周期管理器。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetLifecycleManager(System.Type)">
            <summary>
            根据组件实现类型取得与组件相关的组件生命周期管理器。
            </summary>
            <param name="componentType"> 组件的实现类型。 </param>
            <returns>指定组件类型的生命周期管理器。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetLifecycleManagers(System.Type)">
            <summary>
            根据组件接口类型取得与组件相关的组件生命周期管理器。
            </summary>
            <param name="serviceType"> 组件的接口类型。 </param>
            <returns>指定组件类型的生命周期管理器。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``1">
            <summary>
            根据组件实现类型向容器注册组件实现。
            </summary>		
            <typeparam name="T">组件类型信息。</typeparam>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``1(System.String)">
            <summary>
            根据组件组件key及组件实现类型向容器注册组件实现。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件key。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``2">
            <summary>
            根据组件服务类型及实现类型向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``2(System.String)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``2(System.String,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
            <param name="lifestyleType">生命周期策略。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent``2(System.String,EAS.Objects.Lifecycle.LifestyleType,System.String)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
            <param name="lifestyleType">生命周期策略。</param>
            <param name="lifestyleParameters">生命周期参数。</param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.HasComponent``1">
            <summary>
            根据组件接口类型判断组件容器是否含指定key的组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>存在匹配的组件则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstance``1(System.String)">
            <summary>
            根据组件的key取得组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件的key。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstance``1">
            <summary>
            根据组件的类型取得组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetServiceComponentInstance``1">
            <summary>
            根据组件服务类型取得组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.GetComponentInstances``1">
            <summary>
            根据组件类型取得组件实例列表。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>组件实例列表。</returns>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.Dispose">
            <summary>
            释放资源。
            </summary>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.AddComponent(System.String)">
            <summary>
            内部方法。
            </summary>
            <param name="componentKey"></param>
        </member>
        <member name="M:EAS.Objects.DefaultContainer.OutputAdapters">
            <summary>
            输出适配器定义。
            </summary>
        </member>
        <member name="T:EAS.Objects.ExceptionStackManager">
            <summary>
            容器异常管理器。
            </summary>
        </member>
        <member name="P:EAS.Objects.ExceptionStackManager.Instance">
            <summary>
            唯一实例。
            </summary>
        </member>
        <member name="T:EAS.Objects.IAssemblyLoader">
            <summary>
            IOC容器程序集装载器接口。
            </summary>
            <remarks>
            本接口用于IOC容器的初始化程序集装载，以及发生类型未加载时的处理机制。
            </remarks>
        </member>
        <member name="P:EAS.Objects.IAssemblyLoader.Container">
            <summary>
            目标组件容器。
            </summary>
        </member>
        <member name="M:EAS.Objects.IAssemblyLoader.Initialize">
            <summary>
            初始化容器。
            </summary>
        </member>
        <member name="T:EAS.Objects.IComponentAdapter">
            <summary>
            组件适配器接口，实现不同的组件适配器，用于管理不同的对象实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.ComponentKey">
            <summary>
            返回组件关联的组件索引键。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.Assembly">
            <summary>
            返回组件所在程序集名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.ComponentImplementation">
            <summary>
            返回组件的实现类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.ServiceType">
            <summary>
            返回组件的接口类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.LifestyleType">
            <summary>
            返回组件的生存方式。
            </summary>
        </member>
        <member name="P:EAS.Objects.IComponentAdapter.Container">
            <summary>
            获取或设置一个值，指示级件适合器的组件容器对象。
            </summary>
        </member>
        <member name="M:EAS.Objects.IComponentAdapter.Create">
            <summary>
            创建一个组件实例。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.IComponentAdapter.Destroy(System.Object)">
            <summary>
            销毁组件实例。
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:EAS.Objects.IContainer">
            <summary>
            的组件容器，组件容器管理组件的生存，也是对外提供的一个接口。
            </summary>
        </member>
        <member name="P:EAS.Objects.IContainer.Name">
             <summary>
            获取容器名称。
             </summary>
        </member>
        <member name="P:EAS.Objects.IContainer.ComponentInfos">
            <summary>
            组织配置信息。
            </summary>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(EAS.Objects.ComponentInfo)">
            <summary>
            根据组件组件信息向容器注册组件实现。
            </summary>
            <param name="componentInfo">组件信息。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.String,System.Type)">
            <summary>
            根据组件组件key及组件实现类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation"></param>		
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            根据组件key、接口类型及实现类型中注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.String,System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="lifestyleType"> 组件生命周期方式。 </param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.String,System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType,System.String)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="lifestyleType"> 组件生命周期方式。 </param>
            <param name="lifestyleParameters"> 组件生命周期相关参数，参数为一个字符串，其中由“：”分隔。 </param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.Type)">
            <summary>
            根据组件实现类型向容器注册组件实现。
            </summary>		
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent(System.Type,System.Type)">
            <summary>
            根据组件实现类型及组件接口类型向容器注册组件实现。
            </summary>
            <param name="componentImplementation">组件实现类型。</param>
            <param name="serviceType">组件接口类型。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.RemoveComponent(System.String)">
            <summary>
            从容器中卸载指定的组件。
            </summary>
            <param name="componentKey">组件key。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponentInstance(System.Object)">
            <summary>
            根据组件实例向组件容器中注册组件。
            </summary>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponentInstance(System.String,System.Object)">
            <summary>
            根据组件key及组件实现向组件容器中注册组件。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponentInstance(System.Type)">
            <summary>
            根据组件实现类型向组件容器中注册组件。
            </summary>
            <param name="componentImplementation">组件实现类型。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            根据组件key、接口类型及组件实例向组件容器中注册组件实现。
            </summary>
            <param name="componentKey">组件key。</param>
            <param name="serviceType">组件接口类型。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.HasComponent(System.String)">
            <summary>
            根据组件key判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="componentKey">组件key。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.IContainer.HasComponent(System.Object)">
            <summary>
            根据组件实例判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="componentInstance">组件实例。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.IContainer.HasComponent(System.Type)">
            <summary>
            根据组件接口类型判断组件容器是否含指定key的组件实例。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.IContainer.ReleaseComponent(System.Object)">
            <summary>
            根据组件实例从组件容器中释放组件实例。
            </summary>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstance(System.String)">
            <summary>
            根据组件的key取得组件实例。
            </summary>
            <param name="componentKey">组件的key。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstance(System.Type)">
            <summary>
            根据组件的类型取得组件实例。
            </summary>
            <param name="serviceType">组件类型。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstances(System.Type)">
            <summary>
            根据组件类型取得组件实例列表。
            </summary>
            <param name="serviceType">组件接口类型。</param>
            <returns>组件实例列表。</returns>
        </member>
        <member name="P:EAS.Objects.IContainer.ComponentAdapters">
            <summary>
            获取一个值，该值批示组件容器中的所有组件适配器列表。
            </summary>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentAdapter(System.String)">
            <summary>
            根据组件key取得与组件相关的组件适配器。
            </summary>
            <param name="componentKey">组件的key。</param>
            <returns>指定组件的组件适配器。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentAdapter(System.Type)">
            <summary>
            根据组件类型取得与组件相关的组件适配器。
            </summary>
            <param name="componentType">组件类型。</param>
            <returns>指定组件类型的组件适配器。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``1">
            <summary>
            根据组件实现类型向容器注册组件实现。
            </summary>		
            <typeparam name="T">组件类型信息。</typeparam>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``1(System.String)">
            <summary>
            根据组件组件Key及组件实现类型向容器注册组件实现。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``2">
            <summary>
            根据组件服务类型及实现类型向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``2(System.String)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``2(System.String,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
            <param name="lifestyleType">生命周期策略。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.AddComponent``2(System.String,EAS.Objects.Lifecycle.LifestyleType,System.String)">
            <summary>
            根据组件服务类型、实现类型及生命周期参数向容器注册组件实现。
            </summary>
            <typeparam name="TService">组件服务类型。</typeparam>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件Key。</param>
            <param name="lifestyleType">生命周期策略。</param>
            <param name="lifestyleParameters">生命周期参数。</param>
        </member>
        <member name="M:EAS.Objects.IContainer.HasComponent``1">
            <summary>
            根据组件接口类型判断组件容器是否含指定key的组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>存在匹配的组件则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstance``1(System.String)">
            <summary>
            根据组件的key取得组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <param name="componentKey">组件的key。</param>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstance``1">
            <summary>
            根据组件的类型取得组件实例。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.IContainer.GetComponentInstances``1">
            <summary>
            根据组件类型取得组件实例列表。
            </summary>
            <typeparam name="T">组件类型信息。</typeparam>
            <returns>组件实例列表。</returns>
        </member>
        <member name="T:EAS.Objects.InjectionInfo">
            <summary>
            Objects容器中用于描述一个对象值入器的相关的属性。
            </summary>
        </member>
        <member name="M:EAS.Objects.InjectionInfo.#ctor">
            <summary>
            初始化 ObjectInfo 实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.InjectionInfo.Name">
            <summary>
            获取或设置一个值，批示对象名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.InjectionInfo.Assembly">
            <summary>
            获取或设置一个值，批示对象所在的程序集名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.InjectionInfo.Type">
            <summary>
            获取或设置一个值，批示对象的类型。
            </summary>
        </member>
        <member name="T:EAS.Objects.Injection.AbstractInjetor">
            <summary>
            抽象的注入器接口组件。
            </summary>
        </member>
        <member name="F:EAS.Objects.Injection.AbstractInjetor.keyValue">
            <summary>
            保护的内部成员，接受注入的组件中的注入参数集合，在些集合中存储了属性或构造器注入的相关参数。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.AbstractInjetor.#ctor(System.Object)">
            <summary>
            使用接受注入对象实例创建 AbstractInjetor 类实例。
            </summary>
            <param name="parentInstance">注入对象实例。</param>
        </member>
        <member name="P:EAS.Objects.Injection.AbstractInjetor.ComponentAdapter">
            <summary>
            获取或设置一个值，批示构造器所依赖的组件适配器。
            </summary>
        </member>
        <member name="P:EAS.Objects.Injection.AbstractInjetor.ParentInstance">
            <summary>
            需要注入对象的父组件实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.AbstractInjetor.Add(System.String,System.Object)">
            <summary>
            添加注入对象实例，实现由键、键值组成。
            </summary>
            <param name="key">注入键。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.Injection.AbstractInjetor.Clear">
            <summary>
            清空注入对象实例，实现由键、键值组成。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.AbstractInjetor.Inject">
            <summary>
             完成对象的注入，返回一个注入后的对象实例。
            </summary>
            <returns>注入后的对象实例。</returns>
        </member>
        <member name="P:EAS.Objects.Injection.AbstractInjetor.InjectionType">
            <summary>
            获取一个值，该值指标实现类使用何种注入机制。
            </summary>
        </member>
        <member name="T:EAS.Objects.Injection.ConstructorInjector">
            <summary>
            构造器注入器，完成对象构造函数注入。
            </summary>
            <remarks> 构造注入完成Objects Type 2 构造子注入，两个对象实现的注册使用构造函数进行注入关联。 </remarks>
        </member>
        <member name="M:EAS.Objects.Injection.ConstructorInjector.#ctor">
            <summary>
            初始化 ConstructorInjector 类实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.ConstructorInjector.#ctor(System.Object)">
            <summary>
            使用接受注入对象实例创建 ConstructorInjector 类实例。
            </summary>
            <param name="parentInstance">注入对象实例。</param>
        </member>
        <member name="M:EAS.Objects.Injection.ConstructorInjector.Inject">
            <summary>
            完成对象的注入。
            </summary>
        </member>
        <member name="P:EAS.Objects.Injection.ConstructorInjector.InjectionType">
            <summary>
            获取一个值，该值指标实现类使用何种注入机制。
            </summary>
        </member>
        <member name="T:EAS.Objects.Injection.IInjector">
            <summary>
            组件注入器，完成组件注入机制。
            </summary>
        </member>
        <member name="P:EAS.Objects.Injection.IInjector.ComponentAdapter">
            <summary>
            获取或设置一个值，批示构造器所依赖的组件适配器。
            </summary>
        </member>
        <member name="P:EAS.Objects.Injection.IInjector.ParentInstance">
            <summary>
            需要注入对象的父组件实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.IInjector.Add(System.String,System.Object)">
            <summary>
            添加注入对象实例，实现由键、键值组成。
            </summary>
            <param name="key">注入键。</param>
            <param name="componentInstance">组件实例。</param>
        </member>
        <member name="M:EAS.Objects.Injection.IInjector.Clear">
            <summary>
            清空注入对象实例，实现由键、键值组成。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.IInjector.Inject">
            <summary>
             完成对象的注入，返回一个注入后的对象实例。
            </summary>
            <returns>注入后的对象实例。</returns>
        </member>
        <member name="P:EAS.Objects.Injection.IInjector.InjectionType">
            <summary>
            获取一个值，该值指标实现类使用何种注入机制。
            </summary>
        </member>
        <member name="T:EAS.Objects.Injection.InjectException">
            <summary>
            表示在对象注入过程中所生产的异常信息类。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.InjectException.#ctor">
            <summary>
            初始化 DataException 类的新实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.InjectException.#ctor(System.String)">
            <summary>
            使用异常信息初始化 DataException 类的新实例。
            </summary>
            <param name="message">异常信息。</param>
        </member>
        <member name="M:EAS.Objects.Injection.InjectException.#ctor(System.String,System.Exception)">
            <summary>
            使用异常信息和内部异常对象引用初始化 DataException 类的新实例。
            </summary>
            <param name="message">异常信息。</param>
            <param name="innerException">引发当前异常的内部异常对象引用。</param>
        </member>
        <member name="T:EAS.Objects.Injection.InjectionType">
            <summary>
            枚举InjectorType，对象的注入类型。
            </summary>
        </member>
        <member name="F:EAS.Objects.Injection.InjectionType.PropertyInject">
            <summary>
            PropertyInject，属性注入；Type2 构造子注入 。
            </summary>
        </member>
        <member name="F:EAS.Objects.Injection.InjectionType.ConstructorInject">
            <summary>
            ConstructorInject，构造器注入；即Objects Type3 设值注入 。
            </summary>
        </member>
        <member name="T:EAS.Objects.Injection.PropertyInjector">
            <summary>
            属性注入器，完成对象属性注入。
            </summary>
            <remarks> 
            构造注入完成Objects Type 3 设值子注入，两个对象实现之间的依赖于属性的设值。 '
            </remarks>
        </member>
        <member name="M:EAS.Objects.Injection.PropertyInjector.TypeHelper.GetObjectType(System.Type,System.String)">
            <summary>
            获取包含方法的类型。
            </summary>
            <param name="type">实体对象类型。</param>
            <param name="propertyName">属性名称。</param>
            <returns>实体类型。</returns>
        </member>
        <member name="M:EAS.Objects.Injection.PropertyInjector.#ctor">
            <summary>
            初始化 PropertyInjector 类实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Injection.PropertyInjector.#ctor(System.Object)">
            <summary>
            使用接受注入对象实例创建 PropertyInjector 类实例。
            </summary>
            <param name="parentInstance">注入对象实例。</param>
        </member>
        <member name="M:EAS.Objects.Injection.PropertyInjector.Inject">
            <summary>
            完成对象的注入。
            </summary>
        </member>
        <member name="P:EAS.Objects.Injection.PropertyInjector.InjectionType">
            <summary>
            获取一个值，该值指标实现类使用何种注入机制。
            </summary>
        </member>
        <member name="T:EAS.Objects.Lifecycle.AbstractLifestyleManager">
            <summary>
            抽象的生存周期管理类，定义不同组件生存机制的抽象机别。
            </summary>
        </member>
        <member name="P:EAS.Objects.Lifecycle.AbstractLifestyleManager.Container">
            <summary>
            获取在组件生存周期中的组件容器。
            </summary>
        </member>
        <member name="P:EAS.Objects.Lifecycle.AbstractLifestyleManager.ComponentAdapter">
            <summary>
            获取在组件生存周期中的组件适配器。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.AbstractLifestyleManager.Init(EAS.Objects.IComponentAdapter,EAS.Objects.IContainer)">
            <summary>
            组件生命周期管理，初始化组件。
            </summary>
            <param name="componentAdapter">组件激励器对象。</param>
            <param name="container">组件容器对象。</param>
        </member>
        <member name="M:EAS.Objects.Lifecycle.AbstractLifestyleManager.Resolve">
            <summary>
            组件生命周期管理，返回一个组件实例。
            </summary>
            <returns>按照规定的组件生命周期分配的一个组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.AbstractLifestyleManager.Release(System.Object)">
            <summary>
            组件生命周期管理，释放组件实例。
            </summary>
            <param name="instance">需要释放的组件实例。</param>
        </member>
        <member name="M:EAS.Objects.Lifecycle.AbstractLifestyleManager.Dispose">
            <summary>
            执行与释放或重置非托管资源相关的应用程序定义的任务。
            </summary>
        </member>
        <member name="T:EAS.Objects.Lifecycle.DefaultLifestyleManagerFactory">
            <summary>
            系统默认的接口ILifestyleManagerFactory实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.DefaultLifestyleManagerFactory.#ctor">
            <summary>
            初始化 DefaultLifestyleManagerFactory 类对象实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.DefaultLifestyleManagerFactory.Create(EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="lifestyleType">组件的生命周期方式枚举。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.DefaultLifestyleManagerFactory.Create(EAS.Objects.ComponentInfo)">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="componentInfo">组件相关属性描述。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.DefaultLifestyleManagerFactory.Create(EAS.Objects.Lifecycle.LifestyleType,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="lifestyleType">组件的生命周期方式枚举。</param>
            <param name="parameters" >组件生存周期相关参数。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="T:EAS.Objects.Lifecycle.ILifecycleManager">
            <summary>
            接口 ILifecycleManager ，组件生命周期管理。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifecycleManager.Init(EAS.Objects.IComponentAdapter,EAS.Objects.IContainer)">
            <summary>
            组件生命周期管理，初始化组件。
            </summary>
            <param name="componentAdapter">组件激励器对象。</param>
            <param name="Container">组件容器对象。</param>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifecycleManager.Resolve">
            <summary>
            组件生命周期管理，返回一个组件实例。
            </summary>
            <returns>按照规定的组件生命周期分配的一个组件实例</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifecycleManager.Release(System.Object)">
            <summary>
            组件生命周期管理，释放组件实例。
            </summary>
            <param name="instance"></param>
        </member>
        <member name="P:EAS.Objects.Lifecycle.ILifecycleManager.Container">
            <summary>
            获取组件生成周期对象所在的组件容器。
            </summary>
        </member>
        <member name="P:EAS.Objects.Lifecycle.ILifecycleManager.ComponentAdapter">
            <summary>
            获取组件生成周期对象所在的组件适配器。
            </summary>
        </member>
        <member name="T:EAS.Objects.Lifecycle.ILifestyleManagerFactory">
            <summary>
            ILifestyleManager接口工厂。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifestyleManagerFactory.Create(EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="lifestyleType">组件的生命周期方式枚举。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifestyleManagerFactory.Create(EAS.Objects.ComponentInfo)">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="componentInfo">组件相关属性描述。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.ILifestyleManagerFactory.Create(EAS.Objects.Lifecycle.LifestyleType,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            创建一个ILifestyleManager接口实例组件。
            </summary>
            <param name="lifestyleType">组件的生命周期方式枚举。</param>
            <param name="parameters" >组件生存周期相关参数。</param>
            <returns>与生存周期匹配的 ILifecycleManager 对象实例。</returns>
        </member>
        <member name="T:EAS.Objects.Lifecycle.LifestyleType">
            <summary>
            枚举 LifestyleType 组件的生存方式，即组件以何种生存周期在容器中生存。
            </summary>
        </member>
        <member name="F:EAS.Objects.Lifecycle.LifestyleType.Transient">
            <summary>
            Transient，组件在使用时创建、使用后销毁。
            </summary>
        </member>
        <member name="F:EAS.Objects.Lifecycle.LifestyleType.Singleton">
            <summary>
            Singleton，组件一旦自在，则在所有的客商端中共享。
            </summary>
        </member>
        <member name="F:EAS.Objects.Lifecycle.LifestyleType.Thread">
            <summary>
            Thread，每一个客户端线程拥有单独的一个实例。
            </summary>
        </member>
        <member name="F:EAS.Objects.Lifecycle.LifestyleType.Pooled">
            <summary>
            Pooled，组件池，初始时分配一定数量的组件，客户请求时，分配一个空闲组件，用户使用完后交由池中。
            </summary>
        </member>
        <member name="T:EAS.Objects.Lifecycle.SingletonLifestyleManager">
            <summary>
            组件生存管理周期之Singleton，组件一旦自在，则在所有的客商端中共享。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.SingletonLifestyleManager.#ctor">
            <summary>
            初始化 SingletonLifestyleManager 类对象实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.SingletonLifestyleManager.Resolve">
            <summary>
            组件生命周期管理，返回一个组件实例。
            </summary>
            <returns>按照规定的组件生命周期分配的一个组件实例。</returns>
        </member>
        <member name="M:EAS.Objects.Lifecycle.SingletonLifestyleManager.Release(System.Object)">
            <summary>
            组件生命周期管理，释放组件实例。
            </summary>
            <param name="instance">需要释放的组件实例。</param>
        </member>
        <member name="M:EAS.Objects.Lifecycle.SingletonLifestyleManager.Dispose">
            <summary>
            执行与释放或重置非托管资源相关的应用程序定义的任务。
            </summary>
        </member>
        <member name="T:EAS.Objects.Lifecycle.TransientLifestyleManager">
            <summary>
            组件生存管理周期之Transient，组件在使用时创建、使用后销毁。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.TransientLifestyleManager.#ctor">
            <summary>
            初始化 TransientLifestyleManager 类对象实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Lifecycle.TransientLifestyleManager.Dispose">
            <summary>
            执行与释放或重置非托管资源相关的应用程序定义的任务。
            </summary>
        </member>
        <member name="T:EAS.Objects.Exception">
            <summary>
            表示异常的基类。
            </summary>
        </member>
        <member name="M:EAS.Objects.Exception.#ctor">
            <summary>
            初始化 DataException 类的新实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.Exception.#ctor(System.String)">
            <summary>
            使用异常信息初始化 DataException 类的新实例。
            </summary>
            <param name="message">异常信息。</param>
        </member>
        <member name="M:EAS.Objects.Exception.#ctor(System.String,System.Exception)">
            <summary>
            使用异常信息和内部异常对象引用初始化 DataException 类的新实例。
            </summary>
            <param name="message">异常信息。</param>
            <param name="innerException">引发当前异常的内部异常对象引用。</param>
        </member>
        <member name="T:EAS.Objects.NoComponentException">
            <summary>
            容器中无此组件。
            </summary>
        </member>
        <member name="M:EAS.Objects.NoComponentException.#ctor(System.String)">
            <summary>
            初始化NoComponentException实例。
            </summary>
            <param name="componentKey">组件的key</param>
        </member>
        <member name="M:EAS.Objects.NoComponentException.#ctor(System.Type)">
            <summary>
            初始化NoComponentException实例。
            </summary>
            <param name="componentType">组件的类型信息。</param>
        </member>
        <member name="T:EAS.Objects.NoComponentImplException">
            <summary>
            容器中无此组件。
            </summary>
        </member>
        <member name="M:EAS.Objects.NoComponentImplException.#ctor(System.String)">
            <summary>
            初始化NoComponentException实例。
            </summary>
            <param name="componentKey">组件的key</param>
        </member>
        <member name="T:EAS.Objects.ComponentInfo">
            <summary>
            用于描述一个动态加载的类对象的属性，构造器信息的类。
            </summary>
        </member>
        <member name="M:EAS.Objects.ComponentInfo.#ctor">
            <summary>
            初始化 ComponentInfo 实例。
            </summary>
        </member>
        <member name="M:EAS.Objects.ComponentInfo.#ctor(System.Type,System.Type)">
            <summary>
            初始化 ComponentInfo 实例。
            </summary>
            <param name="TService">服务类型。</param>
            <param name="T">实例类型。</param>
        </member>
        <member name="M:EAS.Objects.ComponentInfo.#ctor(System.Type,System.Type,EAS.Objects.Lifecycle.LifestyleType)">
            <summary>
            初始化 ComponentInfo 实例。
            </summary>
            <param name="TService">服务类型。</param>
            <param name="T">实例类型。</param>
            <param name="lifestyle">生命周期。</param>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Name">
            <summary>
            获取或设置一个值，批示对象名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Assembly">
            <summary>
            获取或设置一个值，批示对象所在的程序集名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Type">
            <summary>
            获取或设置一个值，批示对象的类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Lifestyle">
            <summary>
            获取或设置一个值，批示对象的生命周期方式。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Properties">
            <summary>
            获取或设置一个值，指示对象的属性列表。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Constructors">
            <summary>
            获取或设置一个值，批示对象的构造器列表。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.Parameters">
            <summary>
            获取或设置一个值，批示对象的构造过程需要的相关参数。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.TService">
            <summary>
            组件服务类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.ComponentInfo.T">
            <summary>
            组件服务类型。
            </summary>
        </member>
        <member name="M:EAS.Objects.ComponentInfo.GetComponentType">
            <summary>
            取对象类型。
            </summary>
            <returns></returns>
        </member>
        <member name="M:EAS.Objects.ComponentInfo.ToString">
            <summary>
            返回表示当前对象的的System.String。
            </summary>
            <returns>System.String，表示当前的 System.Object。</returns>
        </member>
        <member name="T:EAS.Objects.PropertyInfo">
            <summary>
            对象属性定义。
            </summary>
        </member>
        <member name="M:EAS.Objects.PropertyInfo.#ctor">
            <summary>
            初始化 PropertyInfo 类实例。
            </summary>
        </member>
        <member name="P:EAS.Objects.PropertyInfo.Name">
            <summary>
            获取或设置一个值，批示属性名称。
            </summary>
        </member>
        <member name="P:EAS.Objects.PropertyInfo.Type">
            <summary>
            获取或设置一个值，批示属性的数据类型。
            </summary>
        </member>
        <member name="P:EAS.Objects.PropertyInfo.Expression">
            <summary>
            获取或设置一个值，批示属性值的表达式。
            </summary>
        </member>
        <member name="T:EAS.Objects.StandardAssemblyLoader">
            <summary>
            标准IOC容器程序集装载器。
            </summary>
        </member>
        <member name="P:EAS.Objects.StandardAssemblyLoader.Container">
            <summary>
            目标组件容器。
            </summary>
        </member>
        <member name="M:EAS.Objects.StandardAssemblyLoader.Initialize">
            <summary>
            初始化容器。
            </summary>
        </member>
        <member name="T:EAS.Security.IPrivileger">
            <summary>
            系统权限所有者(角色，账户)的基本规范。
            </summary>
        </member>
        <member name="P:EAS.Security.IPrivileger.Type">
            <summary>
            获取权限所有者类型，返回权限所有者IPrivilegerOwner枚举。
            </summary>
            <remarks>该值用于说明权限所有者的类型。</remarks>
        </member>
        <member name="P:EAS.Security.IPrivileger.Name">
            <summary>
            获取IDDP系统对象权限所有者名称。
            </summary>
            <remarks>该值用于说明权限所有者的名称。</remarks>
        </member>
        <member name="T:EAS.Security.PrivilegerType">
            <summary>
            定义权限所有者的类型。
            </summary>
        </member>
        <member name="F:EAS.Security.PrivilegerType.Account">
            <summary>
            拥有权限的是帐户。
            </summary>
        </member>
        <member name="F:EAS.Security.PrivilegerType.Role">
            <summary>
            拥有权限的是角色。
            </summary>
        </member>
        <member name="T:EAS.Security.Privileges">
             <summary>
            权限值枚举。
             </summary>
        </member>
        <member name="F:EAS.Security.Privileges.Execute">
             <summary>
            执行权限。
             </summary>
        </member>
        <member name="F:EAS.Security.Privileges.ExecuteEx">
            <summary>
            自定义执行。
            </summary>
        </member>
        <member name="F:EAS.Security.Privileges.Config">
            <summary>
            对象配置。
            </summary>
        </member>
        <member name="F:EAS.Security.Privileges.Delete">
            <summary>
            对象删除。
            </summary>
        </member>
        <member name="T:EAS.Security.Bytes">
            <summary>
            Bytes对象。
            </summary>
            <remarks>为提供字节处理支持，数据加密、CA认证的基础。</remarks>
        </member>
        <member name="M:EAS.Security.Bytes.#ctor">
            <summary>
            初始化 Bytes 类的实例。
            </summary>
        </member>
        <member name="M:EAS.Security.Bytes.Equals(System.Byte[],System.Byte[])">
            <summary>
            判断给定的两个字节数组是否相等。
            </summary>
            <param name="bytes1">要比较的第一个字节数组。</param>
            <param name="bytes2">要比较的第二个字节数组。</param>
            <returns>如果两个字节数组的长度相同，并且相应下标的元素相等，或者两个字节数组都为空引用，则返回true；否则返回false。</returns>
        </member>
        <member name="M:EAS.Security.Bytes.Merge(System.Byte[],System.Byte[])">
            <summary>
            合并指定的两个字节数组。请注意字节数组的顺序。
            </summary>
            <param name="bytes1">要合并的字节数组1。</param>
            <param name="bytes2">要合并的字节数组2。</param>
            <returns>返回合并后的字节数组。</returns>
            <exception cref="T:System.ArgumentNullException">bytes1 或者 bytes2 为空引用。</exception>
        </member>
        <member name="M:EAS.Security.Bytes.ToString(System.Byte[])">
            <summary>
            将指定的字节数组转换为字符串。该字符串的格式为“xx xx ...”，其中“xx”为每一个字节的十六进制表示。
            </summary>
            <param name="buffer">要转换的字节数组。</param>
            <returns>返回已经转换的字节数组字符串。</returns>
        </member>
        <member name="M:EAS.Security.Bytes.FromString(System.String)">
            <summary>
            将格式为“xx xx ...”的字符串（其中“xx”为每一个字节的十六进制表示）转换为相应的字节数组。
            </summary>
            <param name="s">要转换的字符串。</param>
            <returns>返回转换后的字节数组。</returns>
            <exception cref="T:System.ArgumentNullException">s 为空引用。</exception>
            <exception cref="T:System.ArgumentException">字符串 s 格式无效。</exception>
            <remarks>如果 s 为空字符串，则返回长度为 0 的字节数组。</remarks>
        </member>
        <member name="M:EAS.Security.Bytes.ToBase64String(System.Byte[])">
            <summary>
            将指定的 base64 字节数组转换为 base64 字符串。
            </summary>
            <param name="buffer">要转换的 base64 字节数组。</param>
            <returns>返回  base64 字符串</returns>
            <remarks>使用 Convert.ToBase64String。</remarks>
        </member>
        <member name="M:EAS.Security.Bytes.FromBase64String(System.String)">
            <summary>
            将指定的  base64 字符串转换为 base64 字节数组。
            </summary>
            <param name="s">要转换的 base64 字符串。</param>
            <returns>返回 base64 字节数组。</returns>
            <remarks>使用 Convert.FromBase64String。</remarks>
        </member>
        <member name="T:EAS.Security.MD5">
            <summary>
            MD5加密算法。
            </summary>
            <remarks>
            为AgileEAS.NET提供密码生成、密码验证等功能。
            </remarks>	
        </member>
        <member name="T:EAS.Security.DemandAttribute">
            <summary>
            权限验证属性。
            </summary>
            <remarks>
            标记权限模块是否需要验证权限。
            </remarks>
        </member>
        <member name="M:EAS.Security.DemandAttribute.#ctor">
            <summary>
            初始化DemandAttribute对象。
            </summary>
        </member>
        <member name="M:EAS.Security.DemandAttribute.#ctor(System.String)">
            <summary>
            初始化DemandAttribute对象。
            </summary>
            <param name="guid">权限对象Guid。</param>
        </member>
        <member name="M:EAS.Security.DemandAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化DemandAttribute对象。
            </summary>
            <param name="guid">权限对象Guid。</param>
            <param name="name">权限对象名称。</param>
        </member>
        <member name="P:EAS.Security.DemandAttribute.Guid">
            <summary>
            权限对象Guid。
            </summary>
        </member>
        <member name="P:EAS.Security.DemandAttribute.Name">
            <summary>
            权限对象名称。
            </summary>
        </member>
        <member name="T:EAS.Security.DemandIgnoreAttribute">
            <summary>
            权限验证忽略属性。
            </summary>
        </member>
        <member name="M:EAS.Security.DemandIgnoreAttribute.#ctor">
            <summary>
            初始化DemandIgnoreAttribute对象。
            </summary>
        </member>
        <member name="T:EAS.Security.Hash">
            <summary>
            Hash对象。
            </summary>
            <remarks> 为提供散列算法支持，CA认证的基础。为散列提供方法支持。散列算法可以用于进行数字签名。</remarks>
        </member>
        <member name="M:EAS.Security.Hash.#ctor">
            <summary>
            初始化 Hash 类的实例。
            </summary>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.Byte[])">
            <summary>
            计算指定字节数组的哈希值。返回长度为32的字节数组。
            </summary>
            <param name="bytes">要计算其哈希代码的输入。</param>
            <returns>计算所得的哈希代码。该代码长度为32个字节。</returns>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.Byte[],System.Int32)">
            <summary>
            计算指定字节数组的哈希值。返回指定长度（20、32、48、64）的字节数组。
            </summary>
            <param name="bytes">要计算其哈希代码的输入。</param>
            <param name="length">指定希望的哈希代码的长度，单位为字节，目前支持的长度为20、32、48、64。</param>
            <returns>计算所得的哈希代码。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">length 不是20、32、48或者64。</exception>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.IO.Stream)">
            <summary>
            计算Stream的哈希值。返回长度为32的字节数组。
            </summary>
            <param name="stream">要计算其哈希代码的输入。</param>
            <returns>计算所得的哈希代码。该代码长度为32个字节。</returns>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.IO.Stream,System.Int32)">
            <summary>
            计算Stream的哈希值。返回指定长度（20、32、48、64）的字节数组。
            </summary>
            <param name="stream">要计算其哈希代码的输入。</param>
            <param name="length">指定希望的哈希代码的长度，单位为字节，目前支持的长度为20、32、48、64。</param>
            <returns>计算所得的哈希代码。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">length 不是20、32、48或者64。</exception>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            计算指定字节数组的指定区域的哈希值。返回长度为32的字节数组。
            </summary>
            <param name="bytes">要计算其哈希代码的输入。</param>
            <param name="offset">字节数组中的偏移量，从该位置开始使用数据。</param>
            <param name="count">数组中用作数据的字节数。</param>
            <returns>计算所得的哈希代码。该代码长度为32个字节。</returns>
        </member>
        <member name="M:EAS.Security.Hash.Compute(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            计算指定字节数组的指定区域的哈希值。返回指定长度（20、32、48、64）的字节数组。
            </summary>
            <param name="bytes">要计算其哈希代码的输入。</param>
            <param name="offset">字节数组中的偏移量，从该位置开始使用数据。</param>
            <param name="count">数组中用作数据的字节数。</param>
            <param name="length">指定希望的哈希代码的长度，单位为字节，目前支持的长度为20、32、48、64。</param>
            <returns>计算所得的哈希代码。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">length 不是20、32、48或者64。</exception>
        </member>
        <member name="M:EAS.NetSerializer.Primitives.WritePrimitive(System.IO.Stream,System.IntPtr)">
            <summary>
            写System.IntPtr类型，魏琼东 2013/05/10
            </summary>
            <param name="stream"></param>
            <param name="value"></param>
        </member>
        <member name="M:EAS.NetSerializer.Primitives.WritePrimitive(System.IO.Stream,System.UIntPtr)">
            <summary>
            写System.IntPtr类型，魏琼东 2013/05/10
            </summary>
            <param name="stream"></param>
            <param name="value"></param>
        </member>
        <member name="M:EAS.NetSerializer.Primitives.ReadPrimitive(System.IO.Stream,System.IntPtr@)">
            <summary>
            读System.IntPtr类型，魏琼东 2013/05/10
            </summary>
            <param name="stream"></param>
            <param name="value"></param>
        </member>
        <member name="T:EAS.Services.ITimeService">
            <summary>
            时间同步服务接口。
            </summary>
        </member>
        <member name="M:EAS.Services.ITimeService.GetCurrentTime">
            <summary>
            获取系统当前时间。
            </summary>
            <returns>系统当前时间。</returns>
        </member>
        <member name="T:EAS.Services.AsyncCompleted">
            <summary>
            异步方法调用返回。
            </summary>
            <param name="e">返回值参数。</param>
        </member>
        <member name="T:EAS.Services.InvokeValue">
            <summary>
            异步调用返回参数。
            </summary>
        </member>
        <member name="P:EAS.Services.InvokeValue.Error">
            <summary>
            获取一个值，该值指示异步操作期间发生的错误。
            </summary>
        </member>
        <member name="P:EAS.Services.InvokeValue.Data">
            <summary>
            获取一个值，该值指示异步操作的返回结构。
            </summary>
        </member>
        <member name="T:EAS.Services.IServiceBridger">
            <summary>
            服务桥接接口。
            </summary>
        </member>
        <member name="M:EAS.Services.IServiceBridger.InvokeMethod(EAS.Services.ServiceProxyInterceptor,System.Reflection.MethodBase,System.Object[])">
            <summary>
            调用对象方法。
            </summary>
            <param name="interceptor">代理拦截器。</param>
            <param name="method">方法信息。</param>
            <param name="args">参数。</param>
            <returns>调用结果。</returns>
        </member>
        <member name="P:EAS.Services.IServiceBridger.SessionID">
            <summary>
            获取当前会话ID。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceContext">
            <summary>
            对象上下文。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceContainer">
            <summary>
            服务组件容器。
            </summary>
            <remarks>
            用于取得服务组件实例或者服务组件的代理，根据系统当前不同的ServiceBridger桥接完成服务代理组件与服务组件的通信。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(EAS.TaskBase)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="task">回调任务。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(EAS.Services.AsyncCompleted)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="callback">回调函数。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(System.String,EAS.TaskBase)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="serviceBridger">服务桥(Ioc配置中的Key。)</param>
            <param name="task">回调任务。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(System.String,EAS.Services.AsyncCompleted)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="serviceBridger">服务桥(Ioc配置中的Key。)</param>
            <param name="callback">回调函数。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(EAS.Services.IServiceBridger,EAS.TaskBase)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="serviceBridger">服务桥。</param>
            <param name="task">回调任务。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="M:EAS.Services.ServiceContainer.GetService``1(EAS.Services.IServiceBridger,EAS.Services.AsyncCompleted)">
            <summary>
            从容器中取得一个服务/代理组件。
            </summary>
            <typeparam name="T">服务/接口类型。</typeparam>
            <param name="serviceBridger">服务桥。</param>
            <param name="callback">回调函数。</param>
            <returns>服务/代理组件。</returns>
        </member>
        <member name="T:EAS.Services.ServiceMethodAttribute">
            <summary>
            服务方法属性。
            </summary>
            <remarks>
            标记在服务(组件/接口)的公开方法之上，用于标记本方法为一个服务方法，目前主要用于控制细化的权限。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServiceMethodAttribute.#ctor">
            <summary>
            初始化ServiceMethodAttribute对象。
            </summary>
        </member>
        <member name="M:EAS.Services.ServiceMethodAttribute.#ctor(System.String)">
            <summary>
            初始化ServiceMethodAttribute对象。
            </summary>
            <param name="name">名称。</param>
        </member>
        <member name="M:EAS.Services.ServiceMethodAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化ServiceMethodAttribute对象。
            </summary>
            <param name="guid">Guid。</param>
            <param name="name">名称。</param>
        </member>
        <member name="M:EAS.Services.ServiceMethodAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            初始化ServiceMethodAttribute对象。
            </summary>
            <param name="guid">Guid。</param>
            <param name="name">名称。</param>
            <param name="description">说明。</param>
        </member>
        <member name="P:EAS.Services.ServiceMethodAttribute.Guid">
            <summary>
            Guid。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceMethodAttribute.Name">
            <summary>
            名称。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceMethodAttribute.Description">
            <summary>
            说明。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceObject">
            <summary>
            服务组件定义。
            </summary>
            <remarks>
            AgileEAS.NET平台中的服务(组件)基类,非独立接口的服务(组件)请继续自本类。
            </remarks>
        </member>
        <member name="T:EAS.Services.ServiceObjectAttribute">
            <summary>
            服务(组件)属性。
            </summary>
            <remarks>
            标记在服务(组件)之上，用于标记组件为一个服务组件。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServiceObjectAttribute.#ctor">
            <summary>
            初始化ServiceObjectAttribute实例。
            </summary>
        </member>
        <member name="M:EAS.Services.ServiceObjectAttribute.#ctor(System.String)">
            <summary>
            初始化ServiceObjectAttribute实例。
            </summary>
            <param name="name">服务名称</param>
        </member>
        <member name="M:EAS.Services.ServiceObjectAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化ServiceObjectAttribute实例。
            </summary>
            <param name="name">服务名称</param>
            <param name="description">服务描述</param>
        </member>
        <member name="P:EAS.Services.ServiceObjectAttribute.Name">
            <summary>
            获取服务名称。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceObjectAttribute.Description">
            <summary>
            获取服务名称。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceContractAttribute">
            <summary>
            服务(契约/接口)属性。
            </summary>
            <remarks>
            标记在服务(接口)之上，用于标记接口为一个服务契约。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServiceContractAttribute.#ctor">
            <summary>
            初始化ServiceContractAttribute对象实例。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceBindAttribute">
            <summary>
            服务绑定属性。
            </summary>
            <remarks>
            标记在服务(组件)之上，用于实现服务组件与服务契约的绑定。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServiceBindAttribute.#ctor(System.Type)">
            <summary>
            初始化ServiceBindAttribute实例。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceBindAttribute.TContract">
            <summary>
            获取服务契约类型。
            </summary>
        </member>
        <member name="T:EAS.Services.ServicePointAttribute">
            <summary>
            服务点/方法/服务属性。
            </summary>
            <remarks>
            标记在服务(组件/接口)的公开方法之上，用于标记本方法为一个服务方法。
            </remarks>
        </member>
        <member name="M:EAS.Services.ServicePointAttribute.#ctor">
            <summary>
            初始化ServicePointAttribute实例。
            </summary>
        </member>
        <member name="M:EAS.Services.ServicePointAttribute.#ctor(System.String)">
            <summary>
            初始化ServicePointAttribute实例。
            </summary>
            <param name="name">服务名称</param>
        </member>
        <member name="M:EAS.Services.ServicePointAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化ServicePointAttribute实例。
            </summary>
            <param name="name">服务名称</param>
            <param name="description">服务描述</param>
        </member>
        <member name="P:EAS.Services.ServicePointAttribute.Name">
            <summary>
            获取服务名称。
            </summary>
        </member>
        <member name="P:EAS.Services.ServicePointAttribute.Description">
            <summary>
            获取服务名称。
            </summary>
        </member>
        <member name="T:EAS.Services.ServiceProxyInterceptor">
            <summary>
            服务代理拦截器。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceProxyInterceptor.ServiceType">
            <summary>
            服务类型。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceProxyInterceptor.Task">
            <summary>
            回调任务。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceProxyInterceptor.Callback">
            <summary>
            回调函数。
            </summary>
        </member>
        <member name="P:EAS.Services.ServiceProxyInterceptor.ReturnValue">
            <summary>
            调用返回值。
            </summary>
        </member>
        <member name="M:EAS.Services.ServiceProxyInterceptor.Intercept(Castle.DynamicProxy.IInvocation)">
            <summary>
            拦截方法并处理。
            </summary>
            <param name="invocation"></param>
        </member>
        <member name="M:EAS.Services.ServiceProxyInterceptor.GetDefaultReturnValue(Castle.DynamicProxy.IInvocation)">
            <summary>
            获取默认返回值。
            </summary>
            <param name="invocation"></param>
        </member>
        <member name="T:EAS.Services.ServiceSessionManager">
            <summary>
            服务组件管理。
            </summary>
            <remarks>
            用于管理当前环境中的服务会话信息。
            </remarks>
        </member>
        <member name="P:EAS.Services.ServiceSessionManager.Instance">
            <summary>
            ServiceManager对象的唯一实例。
            </summary>
        </member>
        <member name="M:EAS.Services.ServiceSessionManager.Start(System.Guid)">
            <summary>
            启动一个新的服务会话。
            </summary>
            <param name="sessionID">会话唯一标识号。</param>
        </member>
        <member name="M:EAS.Services.ServiceSessionManager.Start(System.Guid,System.Object)">
            <summary>
            启动一个新的服务会话。
            </summary>
            <param name="sessionID">会话唯一标识号。</param>
            <param name="dataTag">数据标记。</param>
        </member>
        <member name="M:EAS.Services.ServiceSessionManager.Abandon(System.Guid)">
            <summary>
            终止指定的服务会话。
            </summary>
            <param name="sessionID">会话唯一标识号。</param>
        </member>
        <member name="M:EAS.Services.ServiceSessionManager.UpdateDataTag(System.Guid,System.Object)">
            <summary>
            更新会话数据标记。
            </summary>
            <param name="sessionID">会话唯一标识号。</param>
            <param name="dataTag">数据标记。</param>
        </member>
        <member name="M:EAS.Services.ServiceSessionManager.GetDataTag(System.Guid)">
            <summary>
            根据会话ID取会话标记。
            </summary>
            <param name="sessionID">会话ID。</param>
            <returns></returns>
        </member>
        <member name="P:EAS.Services.ServiceSessionManager.SessionCount">
            <summary>
            服务会话统计。
            </summary>
        </member>
        <member name="T:EAS.NotifyEventArgs">
            <summary>
            应用通知事件参数。
            </summary>
        </member>
        <member name="M:EAS.NotifyEventArgs.#ctor">
            <summary>
            初始化NotifyEnentArgs事件参数。
            </summary>
        </member>
        <member name="M:EAS.NotifyEventArgs.#ctor(System.String,System.Object)">
            <summary>
            初始化NotifyEnentArgs事件参数。
            </summary>
            <param name="topic">主题。</param>
            <param name="message">消息。</param>
        </member>
        <member name="P:EAS.NotifyEventArgs.Topic">
            <summary>
            主题。
            </summary>
        </member>
        <member name="P:EAS.NotifyEventArgs.Message">
            <summary>
            消息。
            </summary>
        </member>
        <member name="T:EAS.Compressor">
            <summary>
            数据压缩。
            </summary>
        </member>
        <member name="M:EAS.Compressor.Compress(System.Byte[])">
            <summary>
            压缩数据。
            </summary>
            <param name="buffer">待压缩的数据。</param>
            <returns>完成压缩的数据。</returns>
        </member>
        <member name="M:EAS.Compressor.Decompress(System.Byte[])">
            <summary>
            压缩数据。
            </summary>
            <param name="buffer">待压缩的数据。</param>
            <returns>完成压缩的数据。</returns>
        </member>
        <member name="T:EAS.ConfigManager">
            <summary>
            EAS.SL配置管理程序。 
            </summary>
        </member>
        <member name="P:EAS.ConfigManager.Current">
            <summary>
            当前配置管理对象。
            </summary>
        </member>
        <member name="P:EAS.ConfigManager.ConfigPath">
            <summary>
            配置路径。
            </summary>
        </member>
        <member name="P:EAS.ConfigManager.Document">
            <summary>
            配置文档。
            </summary>
        </member>
        <member name="M:EAS.ConfigManager.Load">
            <summary>
            异步初始化配置信息。
            </summary>
        </member>
        <member name="T:EAS.Configuration.Config">
            <summary>
            系统配置读取类。
            </summary>
        </member>
        <member name="F:EAS.Configuration.Config.items">
            <summary>
            系统配置项。
            </summary>
        </member>
        <member name="M:EAS.Configuration.Config.GetValue(System.String)">
            <summary>
            取得指定配置项目的配置值。
            </summary>
            <param name="key"> 系统配置项名称。</param>
            <returns>系统配置项配置值。</returns>
        </member>
        <member name="M:EAS.Configuration.Config.SetValue(System.String,System.String)">
            <summary>
            取得指定配置项目的配置值。
            </summary>
            <param name="key"> 系统配置项名称。</param>
            <param name="value">配置项值。</param>
            <returns>系统配置项配置值。</returns>
        </member>
        <member name="M:EAS.Configuration.Config.Add(System.String,System.String)">
            <summary>
            增加一个系统配置项及其项值。
            </summary>
            <param name="key">配置项名称。</param>
            <param name="value">配置项值。</param>
        </member>
        <member name="P:EAS.Configuration.Config.Count">
            <summary>
            获取系统配置项汇总。
            </summary>
        </member>
        <member name="P:EAS.Configuration.Config.Keys">
            <summary>
            获取所有系统配置项目名称（键）。
            </summary>
        </member>
        <member name="T:EAS.Context.ContextHelper">
             <summary> 
             系统上下文文管理帮助类。 
             </summary> 
            <remarks>
             为系统上下文对象管理与业务支持。
            </remarks>
        </member>
        <member name="M:EAS.Context.ContextHelper.#ctor">
            <summary>
            初始化类对象实例。
            </summary>
        </member>
        <member name="M:EAS.Context.ContextHelper.AddContext(System.String,EAS.Context.IContext)">
            <summary>
            注册上下文对象。
            </summary>
            <param name="name">键。</param>
            <param name="context">上下文对象。</param>
        </member>
        <member name="M:EAS.Context.ContextHelper.Clear">
            <summary>
            清空上下文对象。
            </summary>
        </member>
        <member name="M:EAS.Context.ContextHelper.GetContext(System.String)">
            <summary>
            根据名获取上下文对象。
            </summary>
            <param name="name">名称。</param>
            <returns>上下文对象。</returns>
        </member>
        <member name="M:EAS.Context.ContextHelper.GetContext">
            <summary>
            获取默认的上下文对象。
            </summary>
            <returns>上下文对象。</returns>
        </member>
        <member name="T:EAS.Context.DefaultContext">
            <summary>
            DefaultContex 的摘要说明。
            </summary>
        </member>
        <member name="F:EAS.Context.DefaultContext.container">
            <summary>
            私有内部成员，组件容器工厂，为应用上下文提供组件容器的容器对象。
            </summary>
        </member>
        <member name="M:EAS.Context.DefaultContext.#ctor">
            <summary>
            初始化 DefaultContex 对象实例。
            </summary>
        </member>
        <member name="P:EAS.Context.DefaultContext.Container">
            <summary>
            组件容器，获取系统上下文中的组件容器。
            </summary>
        </member>
        <member name="M:EAS.Context.DefaultContext.IsSingleton(System.String)">
            <summary>
            判定指定名称的组件是生存周期是否为Singleton模式。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的生存周期是否为Singleton模式，是则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.GetLifestyleType(System.String)">
            <summary>
            根据组件名称获取指定组件的生命周期类型。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的生命周期类型。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.ContainsObject(System.String)">
            <summary>
            上下文中是否包含指定名称的组件实例。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>是否包含特定的组件。包含则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.ContainsObject(System.Type)">
            <summary>
            上下文中是否包含指定类型的组件实例。
            </summary>
            <param name="type">组件接口类型。</param>
            <returns>是否包含特定的组件。包含则返回true，否则返回false。</returns>
        </member>
        <member name="P:EAS.Context.DefaultContext.Item(System.String)">
            <summary>
            索引器，根据名称获取指定的组件实例。
            </summary>
        </member>
        <member name="M:EAS.Context.DefaultContext.GetObject(System.String)">
            <summary>
            根据组件的名称返回一个组件实例。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的实例。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.GetObject(System.Type)">
            <summary>
            根据组件的类型返回一个组件实例。
            </summary>
            <param name="type">组件的类型。</param>
            <returns>组件的实例。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.GetType(System.String)">
            <summary>
            根据组件的名称返回组件实例的类型。
            </summary>
            <param name="name">组件名称。</param>
            <returns>组件类型。</returns>
        </member>
        <member name="M:EAS.Context.DefaultContext.ConfigureObject(System.Object)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="target">要配置的组件目标对象。</param>
        </member>
        <member name="M:EAS.Context.DefaultContext.EAS#Context#IContext#ConfigureObject(System.Object,System.String)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="target">要配置的组件目标对象。</param>
            <param name="name">组件名称。</param>
        </member>
        <member name="M:EAS.Context.DefaultContext.ConfigureObject(System.Type)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="type">组件类型。</param>
        </member>
        <member name="M:EAS.Context.DefaultContext.ConfigureObject(System.Type,System.String)">
            <summary>
            在容器中配置组件。
            </summary>		
            <param name="type">组件名称</param>
            <param name="name">组件名称。</param>
        </member>
        <member name="T:EAS.Context.DefaultContextFactory">
            <summary>
            系统缺省的上下文(IContext)生成工厂接口实例。
            </summary>
        </member>
        <member name="M:EAS.Context.DefaultContextFactory.#ctor">
            <summary>
            初始化  DefaultContexFactory 对象实例。
            </summary>
        </member>
        <member name="M:EAS.Context.DefaultContextFactory.Create">
            <summary>
            生成一个上下文接口对象实例。
            </summary>		
            <returns>上下文（IIContext）接口实例。</returns>
        </member>
        <member name="T:EAS.Context.IContext">
            <summary>
            对象上下文，定义IOC组件的上下文。
            </summary>
        </member>
        <member name="P:EAS.Context.IContext.Container">
            <summary>
            组件容器，获取系统上下文中的组件容器。
            </summary>
        </member>
        <member name="M:EAS.Context.IContext.IsSingleton(System.String)">
            <summary>
            判定指定名称的组件是生存周期是否为Singleton模式。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的生存周期是否为Singleton模式，是则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Context.IContext.GetLifestyleType(System.String)">
            <summary>
            根据组件名称获取指定组件的生命周期类型。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的生命周期类型。</returns>
        </member>
        <member name="M:EAS.Context.IContext.ContainsObject(System.String)">
            <summary>
            上下文中是否包含指定名称的组件实例。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>是否包含特定的组件。包含则返回true，否则返回false。</returns>
        </member>
        <member name="M:EAS.Context.IContext.ContainsObject(System.Type)">
            <summary>
            上下文中是否包含指定类型的组件实例。
            </summary>
            <param name="type">组件接口类型。</param>
            <returns>是否包含特定的组件。包含则返回true，否则返回false。</returns>
        </member>
        <member name="P:EAS.Context.IContext.Item(System.String)">
            <summary>
            索引器，根据名称获取指定的组件实例。
            </summary>
        </member>
        <member name="M:EAS.Context.IContext.GetObject(System.String)">
            <summary>
            根据组件的名称返回一个组件实例。
            </summary>
            <param name="name">组件的名称。</param>
            <returns>组件的实例。</returns>
        </member>
        <member name="M:EAS.Context.IContext.GetObject(System.Type)">
            <summary>
            根据组件的类型返回一个组件实例。
            </summary>
            <param name="type">组件的类型。</param>
            <returns>组件的实例。</returns>
        </member>
        <member name="M:EAS.Context.IContext.GetType(System.String)">
            <summary>
            根据组件的名称返回组件实例的类型。
            </summary>
            <param name="name">组件名称。</param>
            <returns>组件类型。</returns>
        </member>
        <member name="M:EAS.Context.IContext.ConfigureObject(System.Object)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="target">要配置的组件目标对象。</param>
        </member>
        <member name="M:EAS.Context.IContext.ConfigureObject(System.Object,System.String)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="target">要配置的组件目标对象。</param>
            <param name="name">组件名称。</param>
        </member>
        <member name="M:EAS.Context.IContext.ConfigureObject(System.Type)">
            <summary>
            在容器中配置组件。
            </summary>
            <param name="type">组件类型。</param>
        </member>
        <member name="M:EAS.Context.IContext.ConfigureObject(System.Type,System.String)">
            <summary>
            在容器中配置组件。
            </summary>		
            <param name="type">组件类型</param>
            <param name="name">组件名称。</param>
        </member>
        <member name="T:EAS.Context.IContextFactory">
            <summary>
            上下文(IContext)生成工厂接口定义。
            </summary>
        </member>
        <member name="M:EAS.Context.IContextFactory.Create">
            <summary>
            生成一个上下文（IContext）接口对象实例。
            </summary>		
            <returns>上下文（IContext）接口实例。</returns>
        </member>
        <member name="T:EAS.DynamicProxy.DynamicProxyFactory">
            <summary>
            动态代理工厂。
            </summary>
        </member>
        <member name="P:EAS.DynamicProxy.DynamicProxyFactory.Instance">
            <summary>
            DynamicProxyFactory对象的唯一实例。
            </summary>
        </member>
        <member name="M:EAS.DynamicProxy.DynamicProxyFactory.CreateProxy``1(Castle.DynamicProxy.IInterceptor)">
            <summary>
            生成一个新的动态代理。
            </summary>
            <param name="interceptor">拦截器。</param>
            <returns>动态代理实例。</returns>
        </member>
        <member name="M:EAS.DynamicProxy.DynamicProxyFactory.CreateProxy``1(System.Object)">
            <summary>
            生成一个新的动态代理。
            </summary>
            <param name="target">代理的目标对象。</param>
            <returns>动态代理实例。</returns>
        </member>
        <member name="M:EAS.DynamicProxy.DynamicProxyFactory.CreateProxy``1(System.Object,Castle.DynamicProxy.IInterceptor)">
            <summary>
            生成一个新的动态代理。
            </summary>
            <param name="target">代理的目标对象。</param>
            <param name="interceptor">拦截器。</param>
            <returns>动态代理实例。</returns>
        </member>
        <member name="T:EAS.EventArgs`1">
            <summary>
            事件参数类。
            </summary>
            <typeparam name="T">事件参数类型。</typeparam>
        </member>
        <member name="M:EAS.EventArgs`1.#ctor(`0)">
            <summary>
            构造方法
            </summary>
            <param name="data">事件参数类型</param>
        </member>
        <member name="P:EAS.EventArgs`1.Data">
            <summary>
            获取参数数据。
            </summary>
        </member>
        <member name="T:EAS.IPlatform">
            <summary>
             AgileEAS.NET中间件/平台中的插件平台定义。
            </summary>
            <remarks>
            IPlatform接口定义了平台与插件结构之中的平台，平台为插件提供当前上下文环境、会话信息以及管理插件的运行。
            </remarks>
        </member>
        <member name="P:EAS.IPlatform.Name">
            <summary>
            获取应用程序名称。
            </summary>
        </member>
        <member name="P:EAS.IPlatform.Context">
            <summary>
            获取对象上下文环境。
            </summary>
        </member>
        <member name="P:EAS.IPlatform.Container">
            <summary>
            获取组件容器。
            </summary>
        </member>
        <member name="P:EAS.IPlatform.Session">
            <summary>
            获取容器的当前会话。
            </summary>
        </member>
        <member name="P:EAS.IPlatform.Time">
            <summary>
            当前系统时间/服务器时间。
            </summary>
        </member>
        <member name="P:EAS.IPlatform.WorkflowRuntime">
            <summary>
            获取工作流运行时环境。
            </summary>
        </member>
        <member name="M:EAS.IPlatform.StartModule(System.Object)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块插件。</param>
        </member>
        <member name="M:EAS.IPlatform.StartModule(System.Type)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块类型。</param>
        </member>
        <member name="M:EAS.IPlatform.StartModule(System.Guid)">
            <summary>
            运行模块。
            </summary>
            <param name="addIn">模块Guid。</param>
        </member>
        <member name="M:EAS.IPlatform.CloseModule(System.Object)">
            <summary>
            关闭模块。
            </summary>
            <param name="addIn">模块插件。</param>
        </member>
        <member name="M:EAS.IPlatform.CloseModule">
            <summary>
            关闭当前模块。
            </summary>
        </member>
        <member name="E:EAS.IPlatform.AddLoad">
            <summary>
            平台成功加载模块之后触发。
            </summary>
        </member>
        <member name="E:EAS.IPlatform.AddInClosing">
            <summary>
            平台关闭模块时触发。
            </summary>
        </member>
        <member name="M:EAS.IPlatform.CallScript(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            执行脚本。
            </summary>
            <param name="script">脚本代码。</param>
            <param name="args">调用参数。</param>
            <remarks>
            动态向用户提供平台的调用。
            </remarks>
        </member>
        <member name="T:EAS.IApplication">
            <summary>
            定义AgileEAS.NET平台应用程序接口。
            </summary>
            <remarks>
            应用程序即插件的运行容器或者插件的运行环境。
            </remarks>
        </member>
        <member name="M:EAS.IApplication.Login(System.String,System.String)">
            <summary>
            账户登录。
            </summary>
            <param name="loginID">账户登录ID。</param>
            <param name="password">账户密码。</param>
        </member>
        <member name="M:EAS.IApplication.Login(System.String,System.String,System.String)">
            <summary>
            账户登录。
            </summary>
            <param name="organization">组织机构。</param>
            <param name="loginID">账户登录ID。</param>
            <param name="password">账户密码。</param>
        </member>
        <member name="M:EAS.IApplication.Logout">
            <summary>
            账户注销。
            </summary>
        </member>
        <member name="M:EAS.IApplication.ChangePassword">
            <summary>
            修改密码。
            </summary>
        </member>
        <member name="M:EAS.IApplication.AppStart">
            <summary>
            启动Windows应用程序。
            </summary>
        </member>
        <member name="M:EAS.IApplication.AppEnd">
            <summary>
            终止Windows应用程序。
            </summary>
        </member>
        <member name="E:EAS.IApplication.Started">
            <summary>
            当平台启动完成后发生。
            </summary>
        </member>
        <member name="E:EAS.IApplication.Notify">
            <summary>
            当平台发出通知时发生。
            </summary>
        </member>
        <member name="T:EAS.Sessions.IClient">
            <summary>
            定义会话的客户端。
            </summary>
        </member>
        <member name="P:EAS.Sessions.IClient.ID">
            <summary>
            获取该客户端的标识。
            </summary>
        </member>
        <member name="T:EAS.Sessions.ISession">
            <summary>
            平台会话，用于定义一个客户/登录/终端与平台的一次/段交互。
            </summary>
        </member>
        <member name="P:EAS.Sessions.ISession.ID">
            <summary>
            会话GuID。
            </summary>
        </member>
        <member name="P:EAS.Sessions.ISession.DataSet">
            <summary>
            会话帐套。
            </summary>
        </member>
        <member name="P:EAS.Sessions.ISession.Organization">
            <summary>
            组织机构。
            </summary>
        </member>
        <member name="P:EAS.Sessions.ISession.Client">
            <summary>
            获取当前会话中的 IClient。
            </summary>
        </member>
        <member name="M:EAS.Sessions.ISession.Start(System.Object[])">
            <summary>
            开始 Client 和 Server 之间的会话。
            </summary>
            <param name="parameters">会话参数。</param>
        </member>
        <member name="M:EAS.Sessions.ISession.Abandon">
            <summary>
            中止 Client 和 Server 之间的会话。
            </summary>
        </member>
        <member name="T:EAS.FuncTask">
            <summary>
            函数任务回调，有返回值。
            </summary>
        </member>
        <member name="M:EAS.FuncTask.CompleteAction">
            <summary>
            已重写，任务完成运作，完成事件之前的处理。
            </summary>
        </member>
        <member name="P:EAS.FuncTask.Result">
            <summary>
            调用结果。
            </summary>
        </member>
        <member name="T:EAS.FuncTask`1">
            <summary>
            函数任务回调(泛型返回值)。
            </summary>
        </member>
        <member name="P:EAS.FuncTask`1.TResult">
            <summary>
            调用结果。
            </summary>
        </member>
        <member name="T:EAS.InvokeTask">
            <summary>
            普通任务回调/无返回值。
            </summary>
        </member>
        <member name="T:EAS.TaskBase">
            <summary>
            任务基类。
            </summary>
        </member>
        <member name="P:EAS.TaskBase.IsComplete">
            <summary>
            是否已经完成。
            </summary>
        </member>
        <member name="P:EAS.TaskBase.TaskResult">
            <summary>
            返回结果。
            </summary>
        </member>
        <member name="P:EAS.TaskBase.Error">
            <summary>
            异常信息。
            </summary>
        </member>
        <member name="P:EAS.TaskBase.HasError">
            <summary>
            是否错误。
            </summary>
        </member>
        <member name="M:EAS.TaskBase.CompleteAction">
            <summary>
            任务完成运作，完成事件之前的处理。
            </summary>
        </member>
        <member name="E:EAS.TaskBase.Completed">
            <summary>
            完成事件。
            </summary>
        </member>
        <member name="M:EAS.TaskBase.Complete(System.Exception)">
            <summary>
            任务完成(错误）。
            </summary>
            <param name="error">错误信息。</param>
        </member>
        <member name="M:EAS.TaskBase.Complete(System.Object)">
            <summary>
            任务完成/返回结果。
            </summary>
            <param name="result">返回结果。</param>
        </member>
        <member name="T:EAS.Workflow.WorkflowAddInAttribute">
            <summary>
            工作流插件属性。
            </summary>
        </member>
        <member name="M:EAS.Workflow.WorkflowAddInAttribute.#ctor(System.String)">
            <summary>
            初始化WorkFlowAddInAttribute对象实例。
            </summary>
            <param name="flowID">流程ID。</param>
        </member>
        <member name="M:EAS.Workflow.WorkflowAddInAttribute.#ctor(System.String,System.Type)">
            <summary>
            初始化WorkFlowAddInAttribute对象实例。
            </summary>
            <param name="flowID">流程ID。</param>
            <param name="tDataEntity">数据实体类型。</param>
        </member>
        <member name="M:EAS.Workflow.WorkflowAddInAttribute.#ctor(System.String,System.String,System.Type)">
            <summary>
            初始化WorkFlowAddInAttribute对象实例。
            </summary>
            <param name="flowID">流程ID。</param>
            <param name="flowName">流程名称。</param>
            <param name="tDataEntity">数据实体类型。</param>
        </member>
        <member name="P:EAS.Workflow.WorkflowAddInAttribute.FlowID">
            <summary>
            工作流ID。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowAddInAttribute.FlowName">
            <summary>
            工作流名称。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowAddInAttribute.TDataEntity">
            <summary>
            数据实体类型。
            </summary>
        </member>
        <member name="T:EAS.Workflow.WorkflowInstanceIdAttribute">
            <summary>
            工作流实例Id属性。
            </summary>
        </member>
        <member name="T:EAS.Workflow.WorkflowComplatedAttribute">
            <summary>
            工作流实例完成属性。
            </summary>
        </member>
        <member name="T:EAS.Workflow.WorkflowTerminatedAttribute">
            <summary>
            工作流实例终止属性。
            </summary>
        </member>
        <member name="T:EAS.Workflow.IWorkflowDataEntity">
            <summary>
            工作流数据实体接口定义。
            </summary>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.Eval``1(System.String)">
            <summary>
            对表达式进行计算/求值。
            </summary>
            <typeparam name="TValue">返回值类型。</typeparam>
            <param name="expression">要计算的表达式,如"1+2+3+4"。</param>
            <returns>返回计算结果,如果带有逻辑运算符则返回true/false,否则返回数。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.Eval(System.String)">
            <summary>
            对表达式进行计算/求值。
            </summary>
            <param name="expression">要计算的表达式,如"1+2+3+4"。</param>
            <returns>返回计算结果,如果带有逻辑运算符则返回true/false,否则返回数。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.SetValue(System.String,System.Object)">
            <summary>
            设置指定属性的值。
            </summary>
            <param name="name">名称名称。</param>
            <param name="value">属性值。</param>
            <returns>对表表达式或者属性值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetValue(System.String)">
            <summary>
            获取指定表达式或者属性的值。
            </summary>
            <param name="expression">表达式或者属性名称。</param>
            <returns>对表表达式或者属性值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetValue``1(System.String)">
            <summary>
            获取指定表达式或者属性的值。
            </summary>
            <typeparam name="TValue">返回值类型。</typeparam>
            <param name="expression">表达式或者属性名称。</param>
            <returns>对表表达式或者属性值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetBoolean(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetDateTime(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetGuid(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetByte(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetInt16(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetInt32(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetInt64(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetDecimal(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetDouble(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetSingle(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowDataEntity.GetString(System.String)">
            <summary>
            计算表达式值，可以为数学表达式，也可以为单一属性值。
            </summary>
            <param name="expression">表达式。</param>
            <returns>表达式值。</returns>
        </member>
        <member name="T:EAS.Workflow.IWorkflowRuntime">
            <summary>
            工作流运行时环境接口。
            </summary>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.CreateWorkflow(System.Object,EAS.Workflow.IWorkflowDataEntity)">
            <summary>
            创建工作流实例。
            </summary>
            <param name="wfAddIn">工作流插件。</param>
            <param name="wfData">工作流业务数据。</param>
            <returns>工作流返回结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.Submit(System.Object)">
            <summary>
            申请提交。
            </summary>
            <param name="wfAddIn">工作流插件。</param>
            <returns>工作流返回结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.Approval(System.Object)">
            <summary>
            审批提交。
            </summary>
            <param name="wfAddIn">工作流插件。</param>
            <returns>工作流返回结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.Submit(System.Guid,System.String,System.String)">
            <summary>
            申请提交。
            </summary>
            <param name="instanceID">实例ID。</param>
            <param name="loginID">提交账号。</param>
            <param name="comment">提交原因。</param>
            <returns>工作流返回结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.Approval(System.Guid,System.String,System.Boolean,System.String)">
            <summary>
            审批提交。
            </summary>
            <param name="instanceID">实例ID。</param>
            <param name="loginID">审批账号。</param>
            <param name="result">审批结果。</param>
            <param name="comment">审批意见。</param>
            <returns>工作流返回结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.GetWorkFlowResult(System.Guid)">
            <summary>
            获取流程实例当前处理结果。
            </summary>
            <param name="instanceID">实例ID。</param>
            <returns>流程处理结果。</returns>
        </member>
        <member name="M:EAS.Workflow.IWorkflowRuntime.GetWorkflowDataEntity(System.Guid)">
            <summary>
            获取流程实例的数据对象。
            </summary>
            <param name="instanceID">实例ID。</param>
            <returns>流程处理结果。</returns>
        </member>
        <member name="T:EAS.Workflow.WorkflowResult">
            <summary>
            工作流处理结果。
            </summary>
        </member>
        <member name="M:EAS.Workflow.WorkflowResult.#ctor">
            <summary>
            初始化WorkflowResult对象实例。
            </summary>
        </member>
        <member name="M:EAS.Workflow.WorkflowResult.#ctor(System.Guid)">
            <summary>
            初始化WorkflowResult对象实例。
            </summary>
            <param name="instanceId">实例ID。</param>
        </member>
        <member name="M:EAS.Workflow.WorkflowResult.#ctor(System.Guid,System.Boolean,System.Boolean)">
            <summary>
            初始化WorkflowResult对象实例。
            </summary>
            <param name="instanceId">实例ID。</param>
            <param name="submit">充许提交。</param>
            <param name="approval">充许审批。</param>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.FlowID">
            <summary>
            流程ID。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.InstanceId">
            <summary>
            实例ID。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Submit">
            <summary>
            是否充许提交。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Approval">
            <summary>
            是否充许审批。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.DataEntity">
            <summary>
            数据实体。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.TDataEntity">
            <summary>
            实体数据类型。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.DataXML">
            <summary>
            实体数据XML。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.IsComplete">
            <summary>
            是否已经完成。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Cancel">
            <summary>
            是否取消操作。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Error">
            <summary>
            异常信息。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Message">
            <summary>
            异常信息/文本。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.Source">
            <summary>
            异常信息/来源。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.TargetSite">
            <summary>
            异常信息/来源。
            </summary>
        </member>
        <member name="P:EAS.Workflow.WorkflowResult.StackTrace">
            <summary>
            异常信息/堆栈。
            </summary>
        </member>
        <member name="E:EAS.Workflow.WorkflowResult.Completed">
            <summary>
            完成事件。
            </summary>
        </member>
        <member name="T:EAS.Workflow.WorkflowTask">
            <summary>
            工作流任务回调，返回值为WorkflowResult。
            </summary>
        </member>
        <member name="M:EAS.Workflow.WorkflowTask.CompleteAction">
            <summary>
            已重写，任务完成运作，完成事件之前的处理。
            </summary>
        </member>
        <member name="F:SharpCompress.Common.ArchiveEncoding.Default">
            <summary>
            Default encoding to use when archive format doesn't specify one.
            </summary>
        </member>
        <member name="F:SharpCompress.Common.ArchiveEncoding.Password">
            <summary>
            Encoding used by encryption schemes which don't comply with RFC 2898.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the same polynomial
            used by Zip. This type is used internally by DotNetZip; it is generally not used
            directly by applications wishing to create, read, or manipulate zip archive
            files.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
            Get the CRC32 for the given (word,byte) combo.  This is a computation
            defined by PKzip.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
            Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
            This is useful when using a divide-and-conquer approach to calculating a CRC.
            Multiple threads can each calculate a CRC32 on a segment of the data, and then
            combine the individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateManager.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream.
            See the constructors that have a <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.FlushType">
            <summary>
            Describes how to flush the current deflate operation. 
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases. 
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream.
            See the doc on constructors that take a <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream">
             <summary>
               A class for compressing and decompressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class is for compression only, and that can be only
               through writing.
             </para>
            
             <para>
               For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE
               Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:SharpCompress.Compressor.Deflate.DeflateStream"/>, except
               that this implementation uses an approach that employs multiple worker
               threads to perform the DEFLATE.  On a multi-cpu or multi-core computer,
               the performance of this class can be significantly higher than the
               single-threaded DeflateStream, particularly for larger streams.  How
               large?  Anything over 10mb is a good candidate for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower
               than the default value.  Your mileage may vary. Finally, for small
               files, the ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead of using the thread pool.
             </para>
            
             </remarks>
             <seealso cref="T:SharpCompress.Compressor.Deflate.DeflateStream" />
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:SharpCompress.Compressor.Deflate.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream,SharpCompress.Compressor.Deflate.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream,SharpCompress.Compressor.Deflate.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream,SharpCompress.Compressor.Deflate.CompressionLevel,SharpCompress.Compressor.Deflate.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BuffersPerCore">
             <summary>
             The number of buffers per CPU or CPU core.
             </summary>
            
             <remarks>
             <para>
               This property sets the number of memory buffers to create, for every
               CPU or CPU core in the machine.  The divide-and-conquer approach
               taken by this class assumes a single thread from the application
               will call Write().  There will be multiple background threads that
               then compress (DEFLATE) the data written into the stream, and also a
               single output thread, also operating in the background, aggregating
               those results and finally emitting the output.
             </para>
            
             <para>
               The default value is 4.  Different values may deliver better or
               worse results, depending on the dynamic performance characteristics
               of your storage and compute resources.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (n*M*S*2), where n is the number of CPUs, M is the multiple (this
               property), S is the size of each buffer (<see cref="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BufferSize"/>),
               and there are 2 buffers used by the compressor, one for input and
               one for output. For example, if your machine has 4 cores, and you
               set BuffersPerCore to 3, and you retain the default buffer size of
               128k, then the ParallelDeflateOutputStream will use 3mb of buffer
               memory in total.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value at any
               time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but result in less effective compression.  For example, using
               the default buffer size of 128k, the compression delivered is within
               1% of the compression delivered by the single-threaded <see
               cref="T:SharpCompress.Compressor.Deflate.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (n*M*S*2), where n is the number of CPUs, M is the multiple (<see
               cref="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BuffersPerCore"/>), S is the size of each buffer (this
               property), and there are 2 buffers used by the compressor, one for
               input and one for output. For example, if your machine has a total
               of 4 cores, and if you set <see cref="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BuffersPerCore"/> to 3, and
               you keep the default buffer size of 128k, then the
               <c>ParallelDeflateOutputStream</c> will use 3mb of buffer memory in
               total.
             </para>
            
             </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Position">
            <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:SharpCompress.Compressor.Deflate.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.   
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data. 
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
             
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.Adler">
            <summary>
            Computes an Adler-32 checksum. 
            </summary>
            <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less
            reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
            is a required part of the "ZLIB" standard.  Applications will almost never need to
            use this class directly.
            </remarks>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.#ctor(SharpCompress.Compressor.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.Inflate(SharpCompress.Compressor.Deflate.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeDeflate(SharpCompress.Compressor.Deflate.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeDeflate(SharpCompress.Compressor.Deflate.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeDeflate(SharpCompress.Compressor.Deflate.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.InitializeDeflate(SharpCompress.Compressor.Deflate.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.Deflate(SharpCompress.Compressor.Deflate.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.SetDeflateParams(SharpCompress.Compressor.Deflate.CompressionLevel,SharpCompress.Compressor.Deflate.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:SharpCompress.Compressor.Deflate.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressor.Deflate.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:SharpCompress.Compressor.Deflate.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream.
            See the constructors that have a  <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressor.Deflate.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:SharpCompress.Utility.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SharpCompress.Utility.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SharpCompress.Utility.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SharpCompress.Utility.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SharpCompress.Utility.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Fills the array with an specific value from an specific index to an specific index.
            </summary>
            <param name="array">The array to be filled.</param>
            <param name="fromindex">The first index to be filled.</param>
            <param name="toindex">The last index to be filled.</param>
            <param name="val">The value to fill the array with.</param>
        </member>
        <member name="M:SharpCompress.Utility.Fill``1(``0[],``0)">
            <summary>
            Fills the array with an specific value.
            </summary>
            <param name="array">The array to be filled.</param>
            <param name="val">The value to fill the array with.</param>
        </member>
        <member name="M:SharpCompress.Utility.readIntBigEndian(System.Byte[],System.Int32)">
            <summary> Read a int value from the byte array at the given position (Big Endian)
            
            </summary>
            <param name="array">the array to read from
            </param>
            <param name="pos">the offset
            </param>
            <returns> the value
            </returns>
        </member>
        <member name="M:SharpCompress.Utility.readShortLittleEndian(System.Byte[],System.Int32)">
            <summary> Read a short value from the byte array at the given position (little
            Endian)
            
            </summary>
            <param name="array">the array to read from
            </param>
            <param name="pos">the offset
            </param>
            <returns> the value
            </returns>
        </member>
        <member name="M:SharpCompress.Utility.readIntLittleEndian(System.Byte[],System.Int32)">
            <summary> Read an int value from the byte array at the given position (little
            Endian)
            
            </summary>
            <param name="array">the array to read from
            </param>
            <param name="pos">the offset
            </param>
            <returns> the value
            </returns>
        </member>
        <member name="M:SharpCompress.Utility.writeIntBigEndian(System.Byte[],System.Int32,System.Int32)">
            <summary> Write an int value into the byte array at the given position (Big endian)
            
            </summary>
            <param name="array">the array
            </param>
            <param name="pos">the offset
            </param>
            <param name="value">the value to write
            </param>
        </member>
        <member name="M:SharpCompress.Utility.WriteLittleEndian(System.Byte[],System.Int32,System.Int16)">
            <summary> Write a short value into the byte array at the given position (little
            endian)
            
            </summary>
            <param name="array">the array
            </param>
            <param name="pos">the offset
            </param>
            <param name="value">the value to write
            </param>
        </member>
        <member name="M:SharpCompress.Utility.incShortLittleEndian(System.Byte[],System.Int32,System.Int16)">
            <summary> Increment a short value at the specified position by the specified amount
            (little endian).
            </summary>
        </member>
        <member name="M:SharpCompress.Utility.WriteLittleEndian(System.Byte[],System.Int32,System.Int32)">
            <summary> Write an int value into the byte array at the given position (little
            endian)
            
            </summary>
            <param name="array">the array
            </param>
            <param name="pos">the offset
            </param>
            <param name="value">the value to write
            </param>
        </member>
        <member name="T:System.SerializableAttribute">
            <summary>
            序列化标记，用于和.NET POCO兼容。
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.SerializationInfo">
            <summary>
            SerializationInfo类，用于和.NET POCO兼容。
            </summary>
        </member>
        <member name="T:System.ComponentModel.DisplayNameAttribute">
            <summary>
            初始化DisplayNameAttribute对象实例。
            </summary>
        </member>
        <member name="M:System.ComponentModel.DisplayNameAttribute.#ctor">
            <summary>
            初始化DisplayNameAttribute对象实例。
            </summary>
        </member>
        <member name="M:System.ComponentModel.DisplayNameAttribute.#ctor(System.String)">
            <summary>
            初始化DisplayNameAttribute对象实例。
            </summary>
            <param name="displayName">显示名称。</param>
        </member>
        <member name="P:System.ComponentModel.DisplayNameAttribute.DisplayName">
            <summary>
            获取显示名称。
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.IContextProperties">
            <summary>
              Interface for Context Properties implementations
            </summary>
            <remarks>
              <para>
                This interface defines a basic property get set accessor.
              </para>
              <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
            </remarks>
        </member>
        <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
            <summary>
              Gets or sets the value of a property
            </summary>
            <value>
              The value for the property with the specified key
            </value>
            <remarks>
              <para>
                Gets or sets the value of a property
              </para>
            </remarks>
        </member>
        <member name="T:Castle.Core.Logging.IExtendedLogger">
            <summary>
              Provides an interface that supports <see cref = "T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
            <summary>
              Exposes the Global Context of the extended logger.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
            <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
            <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
            <summary>
              Gets the configuration file.
            </summary>
            <param name = "fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.Logging.ILogger">
            <summary>
              Manages logging.
            </summary>
            <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
            <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
            <value>True if "debug" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
            <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
            <value>True if "error" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
            <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
            <value>True if "fatal" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
            <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
            <value>True if "info" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
            <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
            <value>True if "warn" messages will be logged.</value>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
            <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name = "loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns>
            <exception cref = "T:System.ArgumentException">If the name has an empty element name.</exception>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
            <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
            <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
            <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
            <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
            <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="T:Castle.Core.Logging.ILoggerFactory">
            <summary>
              Manages the instantiation of <see cref = "T:Castle.Core.Logging.ILogger" />s.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.LoggerLevel">
            <summary>
              Supporting Logger levels.
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Off">
            <summary>
              Logging will be off
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
            <summary>
              Fatal logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Error">
            <summary>
              Error logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
            <summary>
              Warn logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Info">
            <summary>
              Info logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
            <summary>
              Debug logging level
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.NullLogFactory">
            <summary>
            NullLogFactory used when logging is turned off.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
            <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
            <param name = "name">Name.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
            <param name = "name">Name.</param>
            <param name = "level">Level.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.Logging.NullLogger">
            <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
            <summary>
              Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
            <summary>
              Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
            <summary>
              Returns empty context stacks.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
            <summary>
              Returns this <c>NullLogger</c>.
            </summary>
            <param name = "loggerName">Ignored</param>
            <returns>This ILogger instance.</returns>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="T:Castle.Core.Internal.AttributesUtil">
            <summary>
              Helper class for retrieving attributes.
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attribute.
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attribute.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attributes.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
            <summary>
              Gets the type attribute.
            </summary>
            <param name = "type">The type.</param>
            <returns>The type attribute.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
            <summary>
              Gets the type attributes.
            </summary>
            <param name = "type">The type.</param>
            <returns>The type attributes.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
            <summary>
              Gets the type converter.
            </summary>
            <param name = "member">The member.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attribute.
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attribute.</returns>
        </member>
        <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
            <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c>
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
            <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c>
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.Lock.Create">
            <summary>
            Creates a new lock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
            <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
            <typeparam name = "TAttribute">Type of attributes to handle</typeparam>
            <param name = "disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
            <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref = "P:Castle.DynamicProxy.AttributeUtil.FallbackDisassembler" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
            <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
            <summary>
              Interface describing elements composing generated type
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.IsAccessible(System.Reflection.MethodBase)">
            <summary>
              Checks if the method is public or protected.
            </summary>
            <param name = "method"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
              Performs some basic screening and invokes the <see cref = "T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
            <param name = "method"></param>
            <param name = "onlyVirtuals"></param>
            <param name = "hook"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
            <summary>
              Default implementation of <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref = "P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
            <param name = "scope">The module scope for generated proxy types.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
            <summary>
              Handles error during disassembly process
            </summary>
            <param name = "attributeType">Type of the attribute being disassembled</param>
            <param name = "exception">Exception thrown during the process</param>
            <returns>usually null, or (re)throws the exception</returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Object[],System.Reflection.ParameterInfo[])">
            <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
            <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
            <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
            <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
            <param name = "implementer"></param>
            <param name = "interface"></param>
            <param name = "mapping"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
            <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref = "T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para>
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
            <param name = "target">Target element. This is either target type or target method for invocation types.</param>
            <param name = "type">The type of the proxy. This is base type for invocation types.</param>
            <param name = "interfaces">The interfaces.</param>
            <param name = "options">The options.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
            <param name = "target">Type of the target.</param>
            <param name = "interfaces">The interfaces.</param>
            <param name = "options">The options.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
            <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
            <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
            <param name = "gen"></param>
            <param name = "type"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
            <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
            <param name = "gen"></param>
            <param name = "value"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
            <param name = "gen"></param>
            <param name = "type"></param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
            <summary>
              Summary description for PropertiesCollection.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
            <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
            <summary>
              Summary description for NewArrayExpression.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
            <summary>
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
            <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.TypeUtil.GetAllInterfaces(System.Type[])">
            <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
            <param name = "types"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.INamingScope">
            <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
            <summary>
              Gets a unique name based on <paramref name = "suggestedName" />
            </summary>
            <param name = "suggestedName">Name suggested by the caller</param>
            <returns>Unique name based on <paramref name = "suggestedName" />.</returns>
            <remarks>
              Implementers should provide name as closely resembling <paramref name = "suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref = "M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
            <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
            <returns>New naming scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
            <summary>
              Generates the constructor for the class that extends
              <see cref = "T:Castle.DynamicProxy.AbstractInvocation" />
            </summary>
            <param name = "targetFieldType"></param>
            <param name = "proxyGenerationOptions"></param>
            <param name = "baseConstructor"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
            <param name = "name">The name.</param>
            <param name = "declaringType">Type declaring the original event being overriten, or null.</param>
            <param name = "eventDelegateType"></param>
            <param name = "adder">The add method.</param>
            <param name = "remover">The remove method.</param>
            <param name = "attributes">The attributes.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
            <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
            <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
            <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
            <param name = "attribute">An instance of attribute to disassemble</param>
            <returns><see cref = "T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
            <remarks>
              Implementers should return <see cref = "T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name = "attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
            <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
            <summary>
              Changes the target object (<see cref = "P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref = "T:Castle.DynamicProxy.IInvocation" />.
            </summary>
            <param name = "target">The new value of target of invocation.</param>
            <remarks>
              Although the method takes <see cref = "T:System.Object" /> the actual instance must be of type assignable to <see
               cref = "P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref = "T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name = "target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name = "target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.InvalidOperationException" /> will be throws.
            </remarks>
            <exception cref = "T:System.InvalidCastException">Thrown when <paramref name = "target" /> is not assignable to the proxied type.</exception>
        </member>
        <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
            <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
            <param name = "target">The new value of target of the proxy.</param>
            <remarks>
              Although the method takes <see cref = "T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see
               cref = "T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name = "target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name = "target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.InvalidOperationException" /> will be throws.
            </remarks>
            <exception cref = "T:System.InvalidCastException">Thrown when <paramref name = "target" /> is not assignable to the proxied type.</exception>
        </member>
        <member name="T:Castle.DynamicProxy.IInterceptor">
            <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.IInterceptorSelector">
            <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Selects the interceptors that should intercept calls to the given <paramref name = "method" />.
            </summary>
            <param name = "type">The type declaring the method to intercept.</param>
            <param name = "method">The method that will be intercepted.</param>
            <param name = "interceptors">All interceptors registered with the proxy.</param>
            <returns>An array of interceptors to invoke upon calling the <paramref name = "method" />.</returns>
            <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name = "method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name = "interceptors" />.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.IInvocation">
            <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
            <summary>
              Gets the arguments that the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
            <value>The arguments the method was invoked with.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
            <summary>
              Gets the generic arguments of the method.
            </summary>
            <value>The generic arguments, or null if not a generic method.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
            <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
            <seealso cref = "T:Castle.DynamicProxy.IChangeProxyTarget" />
            <value>The invocation target.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Method">
            <summary>
              Gets the <see cref = "T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
            <value>The <see cref = "T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
            <summary>
              For interface proxies, this will point to the <see cref = "T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
            <value>The method invocation target.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
            <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
            <value>Proxy object on which the intercepted method is invoked.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
            <summary>
              Gets or sets the return value of the method.
            </summary>
            <value>The return value of the method.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
            <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
            <value>The type of the target object.</value>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
            <summary>
              Gets the value of the argument at the specified <paramref name = "index" />.
            </summary>
            <param name = "index">The index.</param>
            <returns>The value of the argument at the specified <paramref name = "index" />.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
            <summary>
              Returns the concrete instantiation of the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
            <returns>
              The concrete instantiation of the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
            <remarks>
              Can be slower than calling <see cref = "P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
            <summary>
              Returns the concrete instantiation of <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref = "T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
            <returns>The concrete instantiation of <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
            <remarks>
              In debug builds this can be slower than calling <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
            <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
            <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref = "T:System.NotImplementedException" /> will be thrown.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
            <summary>
              Overrides the value of an argument at the given <paramref name = "index" /> with the
              new <paramref name = "value" /> provided.
            </summary>
            <remarks>
              This method accepts an <see cref = "T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
            <param name = "index">The index of the argument to override.</param>
            <param name = "value">The new value for the argument.</param>
        </member>
        <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternal(System.Reflection.MethodInfo)">
            <summary>
              Determines whether the specified method is internal.
            </summary>
            <param name = "method">The method.</param>
            <returns>
              <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternalToDynamicProxy(System.Reflection.Assembly)">
            <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
            <param name = "asm">The assembly to inspect.</param>
        </member>
        <member name="T:Castle.DynamicProxy.IProxyBuilder">
            <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
            <summary>
              Gets or sets the <see cref = "T:Castle.Core.Logging.ILogger" /> that this <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
            <summary>
              Gets the <see cref = "P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
            <value>The module scope associated with this builder.</value>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "classToProxy" />, using <paramref name = "options" /> provided.
            </summary>
            <param name = "classToProxy">The class type to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "classToProxy" />, implementing <paramref
               name = "additionalInterfacesToProxy" />, using <paramref name = "options" /> provided.
            </summary>
            <param name = "classToProxy">The class type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see
               cref = "M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "classToProxy" />, implementing <paramref
               name = "additionalInterfacesToProxy" />, using <paramref name = "options" /> provided.
            </summary>
            <param name = "classToProxy">The class type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see
               cref = "M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type that proxies calls to <paramref name = "interfaceToProxy" /> members on <paramref
               name = "targetType" />, implementing <paramref name = "additionalInterfacesToProxy" />, using <paramref
               name = "options" /> provided.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "targetType">Type implementing <paramref name = "interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see
               cref = "M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "interfaceToProxy" /> and <parmaref
               name = "additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref = "P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see
               cref = "T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
        </member>
        <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
            <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
            <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
            <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
            <param name = "type">The type which declares the non-virtual member.</param>
            <param name = "memberInfo">The non-virtual member.</param>
            <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
            <param name = "type">The type which declares the given method.</param>
            <param name = "methodInfo">The method to inspect.</param>
            <returns>True if the given method should be proxied; false otherwise.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
            <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
            <summary>
              Gets the interceptors for the proxy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
              The idea is to have reproducable behavior for the case that mixins are registered in different orders.
              This method is here because it is required
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.ModuleScope">
            <summary>
              Summary description for ModuleScope.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
            <summary>
              The default file name used when the assembly is saved using <see cref = "F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
            <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref = "T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
            <param name = "strongAssemblyName">The simple name of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
            <param name = "namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
            <param name = "strongAssemblyName">The simple name of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
            <summary>
              Users of this <see cref = "T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
            <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
            <param name = "key">The key to be looked up in the cache.</param>
            <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
            <summary>
              Registers a type in this scope's type cache.
            </summary>
            <param name = "key">The key to be associated with the type.</param>
            <param name = "type">The type to be stored in the cache.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
            <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
            <summary>
              Gets the strong-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.
            </summary>
            <value>The strong-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
            <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
            <value>The file name of the strongly named module generated by this scope.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
            <summary>
              Gets the weak-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.
            </summary>
            <value>The weak-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
            <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
            <value>The file name of the weakly named module generated by this scope.</value>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
            <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <param name = "isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
            <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref
               name = "isStrongNamed" /> parameter.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
            <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A strong-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
            <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A weak-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
            <param name = "hook">The hook.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.ProxyGenerator">
            <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
            <param name = "builder">Proxy types builder.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
            <summary>
              Gets or sets the <see cref = "T:Castle.Core.Logging.ILogger" /> that this <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
            <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
            <value>The proxy builder.</value>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>Object proxying calls to members of <typeparamref name = "TInterface" /> on <paramref name = "target" /> object.</returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" />is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" />is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see
               cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types  on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptor" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptor" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" />  is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of <paramref name = "additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref
               name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref
               name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for class proxy with given <paramref name = "classToProxy" /> class, implementing given <paramref
               name = "additionalInterfacesToProxy" /> and using provided <paramref name = "options" />.
            </summary>
            <param name = "classToProxy">The base class for proxy type.</param>
            <param name = "additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy with target for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> on given <paramref name = "targetType" /> and using provided <paramref
               name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "targetType">Actual type that the proxy type will encompass.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> on given <paramref name = "interfaceToProxy" /> and using provided <paramref
               name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy without target for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> and using provided <paramref name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
            <summary>
              Holds <see cref = "T:System.Reflection.MethodInfo" /> objects representing methods of <see cref = "T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.SilverlightExtensions.Extensions.IsNested(System.Type)">
            <summary>
            The silverlight System.Type is missing the IsNested property so this exposes similar functionality.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.SilverlightExtensions.EnumHelper">
            <summary>
            http://www.dolittle.com/blogs/einar/archive/2008/01/13/missing-enum-getvalues-when-doing-silverlight-for-instance.aspx
            </summary>
        </member>
    </members>
</doc>
